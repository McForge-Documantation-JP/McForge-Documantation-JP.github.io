{
    "docs": [
        {
            "location": "/",
            "text": "MinecraftForge Documentation\n\n\n\u3053\u306e\u30b5\u30a4\u30c8\u306fMinecraft\u306eModding API\u3067\u3042\u308b\nMinecraftForge\n\u306e\u516c\u5f0f\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u3092\u548c\u8a33\u3057\u305f\u3082\u306e\u3067\u3059\u3002\n\n\n\n\u5f53\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u306fForge \n\u306e\u307f\n \u306b\u95a2\u3059\u308b\u3082\u306e\u3067\u3042\u308a\u3001 \nJava\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u3002\n\n\n\n\n\u82f1\u8a9e\u7248\u306b\u306f\nGitHub\n\u3067\u3001\u7ffb\u8a33\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306b\u306f\n\u7ffb\u8a33\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306eGitHub\n\u3067\u3054\u5354\u529b\u3060\u3055\u3044\u3002",
            "title": "Home"
        },
        {
            "location": "/#minecraftforge-documentation",
            "text": "\u3053\u306e\u30b5\u30a4\u30c8\u306fMinecraft\u306eModding API\u3067\u3042\u308b MinecraftForge \u306e\u516c\u5f0f\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u3092\u548c\u8a33\u3057\u305f\u3082\u306e\u3067\u3059\u3002  \u5f53\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u306fForge  \u306e\u307f  \u306b\u95a2\u3059\u308b\u3082\u306e\u3067\u3042\u308a\u3001  Java\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u3002   \u82f1\u8a9e\u7248\u306b\u306f GitHub \u3067\u3001\u7ffb\u8a33\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306b\u306f \u7ffb\u8a33\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u306eGitHub \u3067\u3054\u5354\u529b\u3060\u3055\u3044\u3002",
            "title": "MinecraftForge Documentation"
        },
        {
            "location": "/styleguide/",
            "text": "\u30b9\u30bf\u30a4\u30eb\u30ac\u30a4\u30c9\n\n\n\u5f53\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u306e\u7de8\u96c6\u306e\u624b\u5f15\u304d\n\n\n\u3053\u306e\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u306f\u8aac\u660e\u3092\u884c\u3046\u3082\u306e\u3067\u3059\u3002\u3084\u308a\u65b9\u3092\u3001\u5206\u304b\u308a\u3084\u3059\u304f\u565b\u307f\u7815\u3044\u3066\u8aac\u660e\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\u308f\u304b\u308a\u3084\u3059\u3044\u30b3\u30fc\u30c9\u306e\u5b9f\u4f8b\u306e\u307f\u3092\u66f8\u304f\u5834\u5408\u306f\u3001Wiki\u304c\u5225\u30b5\u30a4\u30c8\u3068\u3057\u3066\u5b58\u5728\u3057\u307e\u3059\u3002\n\n\n\n\u3053\u306e\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u306f\u3001Forge\u3092\u4f7f\u3063\u3066Mod\u3092\u4f5c\u308b\u65b9\u6cd5\u3092\u77e5\u308a\u305f\u3044\u65b9\u306e\u305f\u3081\u306e\u7269\u3067\u3059\u3002\n\n\n\nJava\u958b\u767a\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u306b\u306f\u3057\u306a\u3044\u3067\u304f\u3060\u3055\u3044\u3002\u305d\u3046\u306a\u308b\u3068\u3001Java\u306e\u30af\u30e9\u30b9\u306e\u50cd\u304d\u65b9\u3084Java\u306e\u57fa\u790e\u7684\u69cb\u9020\u3092\u77e5\u308a\u305f\u3044\u65b9\u306e\u70ba\u306e\u30b5\u30a4\u30c8\u306b\u306a\u3063\u3066\u3057\u307e\u3044\u307e\u3059\u3002\n\n\n\n\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\n\n\n\n\n\u91cd\u8981\n\n\n\n\n!\u2013 important \u2013>\n\n\n\u30a4\u30f3\u30c7\u30f3\u30c8\u633f\u5165\u306f **\u30b9\u30da\u30fc\u30b92\u500b** \u3067\u884c\u3044\u3001Tab\u30ad\u30fc\u3067\u306f\u884c\u308f\u306a\u3044\u3067\u304f\u3060\u3055\u3044\u3002\n<!-- Please use **two spaces** to indent, not tabs. -->\n\n\n\n\u30bf\u30a4\u30c8\u30eb\u306f\u666e\u901a\u306e\u30bf\u30a4\u30c8\u30eb\u306e\u5f62\u5f0f\u3067\u5927\u6587\u5b57\u5316\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059(\u65e5\u672c\u8a9e\u306e\u5834\u5408\u306f\u610f\u8b58\u3059\u308b\u5fc5\u8981\u306f\u3042\u308a\u307e\u305b\u3093)\u3002\u4f8b\u3048\u3070\u3001\n\n\n\n\n\nGuide For Contributing to This Documentation\n\n\nBuilding and Testing Your Mod\n\n\n\n\n\u3068\u3044\u3063\u305f\u98a8\u306b\u3067\u3059\u3002\n\n\n\u57fa\u672c\u3001\u91cd\u8981\u3067\u306a\u3044\u8a9e\u3092\u9664\u3044\u3066\u3059\u3079\u3066\u306e\u5358\u8a9e\u3092\u5927\u6587\u5b57\u5316\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\n\n\n\u300c#\u300d\u3084\u300c##\u300d\u306e\u4ee3\u308f\u308a\u306b\u3001\u30a4\u30b3\u30fc\u30eb\u3084\u30cf\u30a4\u30d5\u30f3\u3092\u4f7f\u3063\u305f\u4e0b\u7dda\u3092\u4f7f\u3046\u3088\u3046\u306b\u3057\u3066\u4e0b\u3055\u3044\u3002h3\u4ee5\u4e0b\u306b\u306f\u300c###\u300d\u306a\u3069\u3092\u4f7f\u7528\u3057\u3066\u5927\u4e08\u592b\u3067\u3059\u3002\u3053\u306e\u30d5\u30a1\u30a4\u30eb\u306e\u30bd\u30fc\u30b9\u306b\u306f\u30a4\u30b3\u30fc\u30eb\u3084\u30cf\u30a4\u30d5\u30f3\u3067\u306e\u4e0b\u7dda\u306e\u4f8b\u304c\u793a\u3055\u308c\u3066\u3044\u307e\u3059\u3002\u30a4\u30b3\u30fc\u30eb\u4e0b\u7dda\u306fh1\u306b\u5f53\u305f\u308b\u6587\u306b\u3001\u30cf\u30a4\u30d5\u30f3\u3092\u7528\u3044\u305f\u4e0b\u7dda\u306fh2\u306b\u5f53\u305f\u308b\u6587\u306b\u305d\u308c\u305e\u308c\u7528\u3044\u3089\u308c\u3066\u3044\u307e\u3059\u3002",
            "title": "Style Guide"
        },
        {
            "location": "/styleguide/#_1",
            "text": "",
            "title": "\u30b9\u30bf\u30a4\u30eb\u30ac\u30a4\u30c9"
        },
        {
            "location": "/styleguide/#_2",
            "text": "\u3053\u306e\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u306f\u8aac\u660e\u3092\u884c\u3046\u3082\u306e\u3067\u3059\u3002\u3084\u308a\u65b9\u3092\u3001\u5206\u304b\u308a\u3084\u3059\u304f\u565b\u307f\u7815\u3044\u3066\u8aac\u660e\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n\u308f\u304b\u308a\u3084\u3059\u3044\u30b3\u30fc\u30c9\u306e\u5b9f\u4f8b\u306e\u307f\u3092\u66f8\u304f\u5834\u5408\u306f\u3001Wiki\u304c\u5225\u30b5\u30a4\u30c8\u3068\u3057\u3066\u5b58\u5728\u3057\u307e\u3059\u3002  \u3053\u306e\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u306f\u3001Forge\u3092\u4f7f\u3063\u3066Mod\u3092\u4f5c\u308b\u65b9\u6cd5\u3092\u77e5\u308a\u305f\u3044\u65b9\u306e\u305f\u3081\u306e\u7269\u3067\u3059\u3002  Java\u958b\u767a\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u306b\u306f\u3057\u306a\u3044\u3067\u304f\u3060\u3055\u3044\u3002\u305d\u3046\u306a\u308b\u3068\u3001Java\u306e\u30af\u30e9\u30b9\u306e\u50cd\u304d\u65b9\u3084Java\u306e\u57fa\u790e\u7684\u69cb\u9020\u3092\u77e5\u308a\u305f\u3044\u65b9\u306e\u70ba\u306e\u30b5\u30a4\u30c8\u306b\u306a\u3063\u3066\u3057\u307e\u3044\u307e\u3059\u3002",
            "title": "\u5f53\u30c9\u30ad\u30e5\u30e1\u30f3\u30c8\u306e\u7de8\u96c6\u306e\u624b\u5f15\u304d"
        },
        {
            "location": "/styleguide/#_3",
            "text": "\u91cd\u8981   !\u2013 important \u2013>  \u30a4\u30f3\u30c7\u30f3\u30c8\u633f\u5165\u306f **\u30b9\u30da\u30fc\u30b92\u500b** \u3067\u884c\u3044\u3001Tab\u30ad\u30fc\u3067\u306f\u884c\u308f\u306a\u3044\u3067\u304f\u3060\u3055\u3044\u3002\n<!-- Please use **two spaces** to indent, not tabs. -->  \u30bf\u30a4\u30c8\u30eb\u306f\u666e\u901a\u306e\u30bf\u30a4\u30c8\u30eb\u306e\u5f62\u5f0f\u3067\u5927\u6587\u5b57\u5316\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059(\u65e5\u672c\u8a9e\u306e\u5834\u5408\u306f\u610f\u8b58\u3059\u308b\u5fc5\u8981\u306f\u3042\u308a\u307e\u305b\u3093)\u3002\u4f8b\u3048\u3070\u3001   Guide For Contributing to This Documentation  Building and Testing Your Mod   \u3068\u3044\u3063\u305f\u98a8\u306b\u3067\u3059\u3002  \u57fa\u672c\u3001\u91cd\u8981\u3067\u306a\u3044\u8a9e\u3092\u9664\u3044\u3066\u3059\u3079\u3066\u306e\u5358\u8a9e\u3092\u5927\u6587\u5b57\u5316\u3057\u3066\u304f\u3060\u3055\u3044\u3002  \u300c#\u300d\u3084\u300c##\u300d\u306e\u4ee3\u308f\u308a\u306b\u3001\u30a4\u30b3\u30fc\u30eb\u3084\u30cf\u30a4\u30d5\u30f3\u3092\u4f7f\u3063\u305f\u4e0b\u7dda\u3092\u4f7f\u3046\u3088\u3046\u306b\u3057\u3066\u4e0b\u3055\u3044\u3002h3\u4ee5\u4e0b\u306b\u306f\u300c###\u300d\u306a\u3069\u3092\u4f7f\u7528\u3057\u3066\u5927\u4e08\u592b\u3067\u3059\u3002\u3053\u306e\u30d5\u30a1\u30a4\u30eb\u306e\u30bd\u30fc\u30b9\u306b\u306f\u30a4\u30b3\u30fc\u30eb\u3084\u30cf\u30a4\u30d5\u30f3\u3067\u306e\u4e0b\u7dda\u306e\u4f8b\u304c\u793a\u3055\u308c\u3066\u3044\u307e\u3059\u3002\u30a4\u30b3\u30fc\u30eb\u4e0b\u7dda\u306fh1\u306b\u5f53\u305f\u308b\u6587\u306b\u3001\u30cf\u30a4\u30d5\u30f3\u3092\u7528\u3044\u305f\u4e0b\u7dda\u306fh2\u306b\u5f53\u305f\u308b\u6587\u306b\u305d\u308c\u305e\u308c\u7528\u3044\u3089\u308c\u3066\u3044\u307e\u3059\u3002",
            "title": "\u30d5\u30a9\u30fc\u30de\u30c3\u30c8"
        },
        {
            "location": "/gettingstarted/",
            "text": "Getting Started with Forge\n\n\nThis is a simple guide to get you from nothing to a basic mod. The rest of this documentation is about where to go from here.\n\n\nFrom Zero to Modding\n\n\n\n\nObtain a source distribution from forge\u2019s \nfiles\n site. (Look for the Mdk file type, or Src in older 1.8/1.7 versions).\n\n\nExtract the downloaded source distribution to an empty directory. You should see a bunch of files, and an example mod is placed in \nsrc/main/java\n for you to look at. Only a few of these files are strictly necessary for mod development, and you may reuse these files for all your projects These files are:\n\n\nbuild.gradle\n\n\ngradlew\n (both \n.bat\n and \n.sh\n)\n\n\nThe \ngradle\n folder\n\n\n\n\n\n\nMove the files listed above to a new folder, this will be your mod project folder.\n\n\nOpen up a command prompt in the folder you created in step (3), then run \ngradlew setupDecompWorkspace\n. This will download a bunch of artifacts from the internet needed to decompile and build Minecraft and forge. This might take some time, as it will download stuff and then decompile Minecraft. Note that, in general, these things will only need to be downloaded and decompiled once, unless you delete the gradle artifact cache.\n\n\nChoose your IDE: Forge explicitly supports developing with Eclipse or IntelliJ environments, but any environment, from Netbeans to vi/emacs, can be made to work.\n\n\nFor Eclipse, you should run \ngradlew eclipse\n - this will download some more artifacts for building eclipse projects and then place the eclipse project artifacts in your current directory.\n\n\nFor IntelliJ, simply import the build.gradle file.\n\n\n\n\n\n\nLoad your project into your IDE.\n\n\nFor Eclipse, create a workspace anywhere (though the easiest location is one level above your project folder). Then simply import your project folder as a project, everything will be done automatically.\n\n\nFor IntelliJ, you only need to create run configs. You can run \ngradlew genIntellijRuns\n to do this.\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nIn case you will receive an error while running the task \n:decompileMC\n ( the fourth step )\n\n\nExecution failed for task ':decompileMc'.\nGC overhead limit exceeded\n\n\nassign more RAM into gradle by adding \norg.gradle.jvmargs=-Xmx2G\n into the file \n~/.gradle/gradle.properties\n (create file if doesn\u2019t exist). The \n~\n sign means it\u2019s a user\u2019s \nhome directory\n    .\n\n\n\n\nTerminal-free IntelliJ IDEA configuration\n\n\nThese instructions assume that you have created the project folder as described in the steps 1 to 3 of the section above. Because of that, the numbering starts at 4.\n\n\n\n\nLaunch IDEA and choose to open/import the \nbuild.gradle\n file, using the default gradle wrapper choice. While you wait for this process to finish, you can open the gradle panel, which will get filled with the gradle tasks once importing is completed.\n\n\nRun the \nsetupDecompWorkspace\n task (inside the \nforgegradle\n task group). It will take a few minutes, and use quite a bit of RAM. If it fails, you can add \n-Xmx3G\n to the \nGradle VM options\n in IDEA\u2019s gradle settings window, or edit your global gradle properties.\n\n\nOnce the setup task is done, you will want to run the \ngenIntellijRuns\n task, which will configure the project\u2019s run/debug targets. \n\n\nAfter it\u2019s done, you should click the blue refresh icon \non the gradle panel\n (there\u2019s another refresh icon on the main toolbar, but that\u2019s not it). This will re-synchronize the IDEA project with the Gradle data, making sure that all the dependencies and settings are up to date.\n\n\nFinally, assuming you use IDEA 2016 or newer, you will have to fix the classpath module. Go to \nEdit configurations\n and in both \nMinecraft Client\n and \nMinecraft Server\n, change \nUse classpath of module\n to point to the task with a name like \n<project>_main\n.\n\n\n\n\nIf all the steps worked correctly, you should now be able to choose the Minecraft run tasks from the dropdown, and then click the Run/Debug buttons to test your setup.\n\n\nCustomizing Your Mod Information\n\n\nEdit the \nbuild.gradle\n file to customize how your mod is built (the file names, versions, and other things).\n\n\n\n\nImportant\n\n\nDo not\n edit the \nbuildscript {}\n section of the build.gradle file, its default text is necessary for ForgeGradle to function.\n\n\n\n\nAlmost anything underneath \napply project: forge\n and the \n// EDITS GO BELOW HERE\n marker can be changed, many things can be removed and customized there as well.\n\n\nThere is a whole site dedicated to customizing the forge \nbuild.gradle\n files - the \nForgeGradle cookbook\n. Once you\u2019re comfortable with your mod setup, you\u2019ll find many useful recipes there.\n\n\nSimple \nbuild.gradle\n Customizations\n\n\nThese customizations are highly recommended for all projects.\n\n\n\n\nTo change the name of the file you build - edit the value of \narchivesBaseName\n to suit.\n\n\nTo change your \u201cmaven coordinates\u201d - edit the value of \ngroup\n as well.\n\n\nTo change the version number - edit the value of \nversion\n.\n\n\n\n\nBuilding and Testing Your Mod\n\n\n\n\nTo build your mod, run \ngradlew build\n. This will output a file in \nbuild/libs\n with the name \n[archivesBaseName]-[version].jar\n. This file can be placed in the \nmods\n folder of a forge enabled Minecraft setup, and distributed.\n\n\nTo test run with your mod, the easiest way is to use the run configs that were generated when you set up your project. Otherwise, you can run \ngradlew runClient\n. This will launch Minecraft from the \n<runDir>\n location, including your mod code. There are various customizations to this command. Consult the \nForgeGradle cookbook\n for more information.\n\n\nYou can also run a dedicated server using the server run config, or \ngradlew runServer\n. This will launch the Minecraft server with it\u2019s GUI.\n\n\n\n\n\n\nNote\n\n\nIt is always advisable to test your mod in a dedicated server environment if it is intended to run there.",
            "title": "Home"
        },
        {
            "location": "/gettingstarted/#getting-started-with-forge",
            "text": "This is a simple guide to get you from nothing to a basic mod. The rest of this documentation is about where to go from here.",
            "title": "Getting Started with Forge"
        },
        {
            "location": "/gettingstarted/#from-zero-to-modding",
            "text": "Obtain a source distribution from forge\u2019s  files  site. (Look for the Mdk file type, or Src in older 1.8/1.7 versions).  Extract the downloaded source distribution to an empty directory. You should see a bunch of files, and an example mod is placed in  src/main/java  for you to look at. Only a few of these files are strictly necessary for mod development, and you may reuse these files for all your projects These files are:  build.gradle  gradlew  (both  .bat  and  .sh )  The  gradle  folder    Move the files listed above to a new folder, this will be your mod project folder.  Open up a command prompt in the folder you created in step (3), then run  gradlew setupDecompWorkspace . This will download a bunch of artifacts from the internet needed to decompile and build Minecraft and forge. This might take some time, as it will download stuff and then decompile Minecraft. Note that, in general, these things will only need to be downloaded and decompiled once, unless you delete the gradle artifact cache.  Choose your IDE: Forge explicitly supports developing with Eclipse or IntelliJ environments, but any environment, from Netbeans to vi/emacs, can be made to work.  For Eclipse, you should run  gradlew eclipse  - this will download some more artifacts for building eclipse projects and then place the eclipse project artifacts in your current directory.  For IntelliJ, simply import the build.gradle file.    Load your project into your IDE.  For Eclipse, create a workspace anywhere (though the easiest location is one level above your project folder). Then simply import your project folder as a project, everything will be done automatically.  For IntelliJ, you only need to create run configs. You can run  gradlew genIntellijRuns  to do this.      Note  In case you will receive an error while running the task  :decompileMC  ( the fourth step )  Execution failed for task ':decompileMc'.\nGC overhead limit exceeded  assign more RAM into gradle by adding  org.gradle.jvmargs=-Xmx2G  into the file  ~/.gradle/gradle.properties  (create file if doesn\u2019t exist). The  ~  sign means it\u2019s a user\u2019s  home directory     .",
            "title": "From Zero to Modding"
        },
        {
            "location": "/gettingstarted/#terminal-free-intellij-idea-configuration",
            "text": "These instructions assume that you have created the project folder as described in the steps 1 to 3 of the section above. Because of that, the numbering starts at 4.   Launch IDEA and choose to open/import the  build.gradle  file, using the default gradle wrapper choice. While you wait for this process to finish, you can open the gradle panel, which will get filled with the gradle tasks once importing is completed.  Run the  setupDecompWorkspace  task (inside the  forgegradle  task group). It will take a few minutes, and use quite a bit of RAM. If it fails, you can add  -Xmx3G  to the  Gradle VM options  in IDEA\u2019s gradle settings window, or edit your global gradle properties.  Once the setup task is done, you will want to run the  genIntellijRuns  task, which will configure the project\u2019s run/debug targets.   After it\u2019s done, you should click the blue refresh icon  on the gradle panel  (there\u2019s another refresh icon on the main toolbar, but that\u2019s not it). This will re-synchronize the IDEA project with the Gradle data, making sure that all the dependencies and settings are up to date.  Finally, assuming you use IDEA 2016 or newer, you will have to fix the classpath module. Go to  Edit configurations  and in both  Minecraft Client  and  Minecraft Server , change  Use classpath of module  to point to the task with a name like  <project>_main .   If all the steps worked correctly, you should now be able to choose the Minecraft run tasks from the dropdown, and then click the Run/Debug buttons to test your setup.",
            "title": "Terminal-free IntelliJ IDEA configuration"
        },
        {
            "location": "/gettingstarted/#customizing-your-mod-information",
            "text": "Edit the  build.gradle  file to customize how your mod is built (the file names, versions, and other things).   Important  Do not  edit the  buildscript {}  section of the build.gradle file, its default text is necessary for ForgeGradle to function.   Almost anything underneath  apply project: forge  and the  // EDITS GO BELOW HERE  marker can be changed, many things can be removed and customized there as well.  There is a whole site dedicated to customizing the forge  build.gradle  files - the  ForgeGradle cookbook . Once you\u2019re comfortable with your mod setup, you\u2019ll find many useful recipes there.",
            "title": "Customizing Your Mod Information"
        },
        {
            "location": "/gettingstarted/#simple-buildgradle-customizations",
            "text": "These customizations are highly recommended for all projects.   To change the name of the file you build - edit the value of  archivesBaseName  to suit.  To change your \u201cmaven coordinates\u201d - edit the value of  group  as well.  To change the version number - edit the value of  version .",
            "title": "Simple build.gradle Customizations"
        },
        {
            "location": "/gettingstarted/#building-and-testing-your-mod",
            "text": "To build your mod, run  gradlew build . This will output a file in  build/libs  with the name  [archivesBaseName]-[version].jar . This file can be placed in the  mods  folder of a forge enabled Minecraft setup, and distributed.  To test run with your mod, the easiest way is to use the run configs that were generated when you set up your project. Otherwise, you can run  gradlew runClient . This will launch Minecraft from the  <runDir>  location, including your mod code. There are various customizations to this command. Consult the  ForgeGradle cookbook  for more information.  You can also run a dedicated server using the server run config, or  gradlew runServer . This will launch the Minecraft server with it\u2019s GUI.    Note  It is always advisable to test your mod in a dedicated server environment if it is intended to run there.",
            "title": "Building and Testing Your Mod"
        },
        {
            "location": "/gettingstarted/structuring/",
            "text": "Structuring Your Mod\n\n\nWe\u2019ll look at how to organize your mod into different files and what those files should do.\n\n\nPackaging\n\n\nPick a unique package name. If you own a URL associated with your project, you can use it as your top level package. For example if you own \u201cexample.com\u201d, you may use \ncom.example\n as your top level package.\n\n\n\n\nImportant\n\n\nIf you do not own a domain, do not use it for your top level package. It is perfectly acceptable to start your package with anything, such as your name/nickname, or the name of the mod.\n\n\n\n\nAfter the top level package (if you have one) you append a unique name for your mod, such as \nexamplemod\n. In our case it will end up as \ncom.example.examplemod\n.\n\n\nThe \nmcmod.info\n file\n\n\nThis file defines the metadata of your mod. Its information may be viewed by users from the main screen of the game through the Mods button. A single info file can describe several mods. When a mod is annotated by the \n@Mod\n annotation, it may define the \nuseMetadata\n property, which defaults to \nfalse\n. When \nuseMetadata\n is \ntrue\n, the metadata within \nmcmod.info\n overrides whatever has been defined in the annotation.\n\n\nThe \nmcmod.info\n file is formatted as JSON, where the root element is a list of objects and each object describes one modid. It should be stored as \nsrc/main/resources/mcmod.info\n. A basic \nmcmod.info\n, describing one mod, may look like this:\n\n\n[{\n  \"modid\": \"examplemod\",\n  \"name\": \"Example Mod\",\n  \"description\": \"Lets you craft dirt into diamonds. This is a traditional mod that has existed for eons. It is ancient. The holy Notch created it. Jeb rainbowfied it. Dinnerbone made it upside down. Etc.\",\n  \"version\": \"1.0.0.0\",\n  \"mcversion\": \"1.10.2\",\n  \"logoFile\": \"assets/examplemod/textures/logo.png\",\n  \"url\": \"minecraftforge.net/\",\n  \"updateJSON\": \"minecraftforge.net/versions.json\",\n  \"authorList\": [\"Author\"],\n  \"credits\": \"I'd like to thank my mother and father.\",\n}]\n\n\n\nThe default Gradle configuration replaces \n${version}\n with the project version, and \n${mcversion}\n with the Minecraft version, but \nonly\n within \nmcmod.info\n, so you should use those instead of directly writing them out. Here is a table of attributes that may be given to a mod, where \nrequired\n means there is no default and the absence of the property causes an error. In addition to the required properties, you should also define \ndescription\n, \nversion\n, \nmcversion\n, \nurl\n, and \nauthorList\n.\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmodid\n\n\nstring\n\n\nrequired\n\n\nThe modid this description is linked to. If the mod is not loaded, the description is ignored.\n\n\n\n\n\n\nname\n\n\nstring\n\n\nrequired\n\n\nThe user-friendly name of this mod.\n\n\n\n\n\n\ndescription\n\n\nstring\n\n\n\"\"\n\n\nA description of this mod in 1-2 paragraphs.\n\n\n\n\n\n\nversion\n\n\nstring\n\n\n\"\"\n\n\nThe version of the mod.\n\n\n\n\n\n\nmcversion\n\n\nstring\n\n\n\"\"\n\n\nThe Minecraft version.\n\n\n\n\n\n\nurl\n\n\nstring\n\n\n\"\"\n\n\nA link to the mod\u2019s homepage.\n\n\n\n\n\n\nupdateUrl\n\n\nstring\n\n\n\"\"\n\n\nDefined but unused. Superseded by updateJSON.\n\n\n\n\n\n\nupdateJSON\n\n\nstring\n\n\n\"\"\n\n\nThe URL to a \nversion JSON\n.\n\n\n\n\n\n\nauthorList\n\n\n[string]\n\n\n[]\n\n\nA list of authors to this mod.\n\n\n\n\n\n\ncredits\n\n\nstring\n\n\n\"\"\n\n\nA string that contains any acknowledgements you want to mention.\n\n\n\n\n\n\nlogoFile\n\n\nstring\n\n\n\"\"\n\n\nThe path to the mod\u2019s logo. It is resolved on top of the classpath, so you should put it in a location where the name will not conflict, maybe under your own assets folder.\n\n\n\n\n\n\nscreenshots\n\n\n[string]\n\n\n[]\n\n\nA list of images to be shown on the info page. Currently unimplemented.\n\n\n\n\n\n\nparent\n\n\nstring\n\n\n\"\"\n\n\nThe modid of a parent mod, if applicable. Using this allows modules of another mod to be listed under it in the info page, like BuildCraft.\n\n\n\n\n\n\nuseDependencyInformation\n\n\nboolean\n\n\nfalse\n\n\nIf true and \nMod.useMetadata\n, the below 3 lists of dependencies will be used. If not, they do nothing.\n\n\n\n\n\n\nrequiredMods\n\n\n[string]\n\n\n[]\n\n\nA list of modids. If one is missing, the game will crash. This \ndoes not affect the \nordering\n of mod loading!\n To specify ordering as well as requirement, have a coupled entry in \ndependencies\n.\n\n\n\n\n\n\ndependencies\n\n\n[string]\n\n\n[]\n\n\nA list of modids. All of the listed mods will load \nbefore\n this one. If one is not present, nothing happens.\n\n\n\n\n\n\ndependants\n\n\n[string]\n\n\n[]\n\n\nA list of modids. All of the listed mods will load \nafter\n this one. If one is not present, nothing happens.\n\n\n\n\n\n\n\n\nA good example \nmcmod.info\n that uses many of these properties is \nBuildCraft\n.\n\n\nThe Mod File\n\n\nGenerally, we\u2019ll start with a file named after your mod, and put into your package. This is the \nentry point\n to your mod\nand will contain some special indicators marking it as such.\n\n\nWhat is \n@Mod\n?\n\n\nThis is an annotation indicating to the Forge Mod Loader that the class is a Mod entry point. It contains various metadata about the mod. It also designates the class that will receive \n@EventHandler\n events. More information can be found at\u2026 (Coming Soon)\n\n\nYou can find an example mod in the \nForge src download\n.\n\n\nKeeping Your Code Clean Using Sub-packages\n\n\nRather than clutter up a single class and package with everything, it is recommended you break your mod into subpackages.\n\n\nA common subpackage strategy has packages for \ncommon\n and \nclient\n code, which is code that can be run on server/client and client, respectively. Inside the \ncommon\n package would go things like Items, Blocks, and Tile Entities (which can each in turn be another subpackage). Things like GUIs and Renderers would go inside the \nclient\n package.\n\n\n\n\nNote\n\n\nThis package style is only a suggestion, though it is a commonly used style. Feel free to use your own packaging system.\n\n\n\n\nBy keeping your code in clean subpackages, you can grow your mod much more organically.\n\n\nClass Naming Schemes\n\n\nA common class naming scheme allows easier deciphering of what a class is, and also makes it easier for someone developing with your mod to find things.\n\n\nFor Example:\n\n\n\n\nAn \nItem\n called \nPowerRing\n would be in an \nitem\n package, with a class name of \nItemPowerRing\n.\n\n\nA \nBlock\n called \nNotDirt\n would be in a \nblock\n package, with a class name of \nBlockNotDirt\n.\n\n\nFinally, a \nTileEntity\n for a block called \nSuperChewer\n would be a \ntile\n or \ntileentity\n package, with a class name of \nTileSuperChewer\n.\n\n\n\n\nPrepending your class names with what \nkind\n of object they are makes it easier to figure out what a class is, or guess the class for an object.",
            "title": "Structuring Your Mod"
        },
        {
            "location": "/gettingstarted/structuring/#structuring-your-mod",
            "text": "We\u2019ll look at how to organize your mod into different files and what those files should do.",
            "title": "Structuring Your Mod"
        },
        {
            "location": "/gettingstarted/structuring/#packaging",
            "text": "Pick a unique package name. If you own a URL associated with your project, you can use it as your top level package. For example if you own \u201cexample.com\u201d, you may use  com.example  as your top level package.   Important  If you do not own a domain, do not use it for your top level package. It is perfectly acceptable to start your package with anything, such as your name/nickname, or the name of the mod.   After the top level package (if you have one) you append a unique name for your mod, such as  examplemod . In our case it will end up as  com.example.examplemod .",
            "title": "Packaging"
        },
        {
            "location": "/gettingstarted/structuring/#the-mcmodinfo-file",
            "text": "This file defines the metadata of your mod. Its information may be viewed by users from the main screen of the game through the Mods button. A single info file can describe several mods. When a mod is annotated by the  @Mod  annotation, it may define the  useMetadata  property, which defaults to  false . When  useMetadata  is  true , the metadata within  mcmod.info  overrides whatever has been defined in the annotation.  The  mcmod.info  file is formatted as JSON, where the root element is a list of objects and each object describes one modid. It should be stored as  src/main/resources/mcmod.info . A basic  mcmod.info , describing one mod, may look like this:  [{\n  \"modid\": \"examplemod\",\n  \"name\": \"Example Mod\",\n  \"description\": \"Lets you craft dirt into diamonds. This is a traditional mod that has existed for eons. It is ancient. The holy Notch created it. Jeb rainbowfied it. Dinnerbone made it upside down. Etc.\",\n  \"version\": \"1.0.0.0\",\n  \"mcversion\": \"1.10.2\",\n  \"logoFile\": \"assets/examplemod/textures/logo.png\",\n  \"url\": \"minecraftforge.net/\",\n  \"updateJSON\": \"minecraftforge.net/versions.json\",\n  \"authorList\": [\"Author\"],\n  \"credits\": \"I'd like to thank my mother and father.\",\n}]  The default Gradle configuration replaces  ${version}  with the project version, and  ${mcversion}  with the Minecraft version, but  only  within  mcmod.info , so you should use those instead of directly writing them out. Here is a table of attributes that may be given to a mod, where  required  means there is no default and the absence of the property causes an error. In addition to the required properties, you should also define  description ,  version ,  mcversion ,  url , and  authorList .     Property  Type  Default  Description      modid  string  required  The modid this description is linked to. If the mod is not loaded, the description is ignored.    name  string  required  The user-friendly name of this mod.    description  string  \"\"  A description of this mod in 1-2 paragraphs.    version  string  \"\"  The version of the mod.    mcversion  string  \"\"  The Minecraft version.    url  string  \"\"  A link to the mod\u2019s homepage.    updateUrl  string  \"\"  Defined but unused. Superseded by updateJSON.    updateJSON  string  \"\"  The URL to a  version JSON .    authorList  [string]  []  A list of authors to this mod.    credits  string  \"\"  A string that contains any acknowledgements you want to mention.    logoFile  string  \"\"  The path to the mod\u2019s logo. It is resolved on top of the classpath, so you should put it in a location where the name will not conflict, maybe under your own assets folder.    screenshots  [string]  []  A list of images to be shown on the info page. Currently unimplemented.    parent  string  \"\"  The modid of a parent mod, if applicable. Using this allows modules of another mod to be listed under it in the info page, like BuildCraft.    useDependencyInformation  boolean  false  If true and  Mod.useMetadata , the below 3 lists of dependencies will be used. If not, they do nothing.    requiredMods  [string]  []  A list of modids. If one is missing, the game will crash. This  does not affect the  ordering  of mod loading!  To specify ordering as well as requirement, have a coupled entry in  dependencies .    dependencies  [string]  []  A list of modids. All of the listed mods will load  before  this one. If one is not present, nothing happens.    dependants  [string]  []  A list of modids. All of the listed mods will load  after  this one. If one is not present, nothing happens.     A good example  mcmod.info  that uses many of these properties is  BuildCraft .",
            "title": "The mcmod.info file"
        },
        {
            "location": "/gettingstarted/structuring/#the-mod-file",
            "text": "Generally, we\u2019ll start with a file named after your mod, and put into your package. This is the  entry point  to your mod\nand will contain some special indicators marking it as such.",
            "title": "The Mod File"
        },
        {
            "location": "/gettingstarted/structuring/#what-is-mod",
            "text": "This is an annotation indicating to the Forge Mod Loader that the class is a Mod entry point. It contains various metadata about the mod. It also designates the class that will receive  @EventHandler  events. More information can be found at\u2026 (Coming Soon)  You can find an example mod in the  Forge src download .",
            "title": "What is @Mod?"
        },
        {
            "location": "/gettingstarted/structuring/#keeping-your-code-clean-using-sub-packages",
            "text": "Rather than clutter up a single class and package with everything, it is recommended you break your mod into subpackages.  A common subpackage strategy has packages for  common  and  client  code, which is code that can be run on server/client and client, respectively. Inside the  common  package would go things like Items, Blocks, and Tile Entities (which can each in turn be another subpackage). Things like GUIs and Renderers would go inside the  client  package.   Note  This package style is only a suggestion, though it is a commonly used style. Feel free to use your own packaging system.   By keeping your code in clean subpackages, you can grow your mod much more organically.",
            "title": "Keeping Your Code Clean Using Sub-packages"
        },
        {
            "location": "/gettingstarted/structuring/#class-naming-schemes",
            "text": "A common class naming scheme allows easier deciphering of what a class is, and also makes it easier for someone developing with your mod to find things.  For Example:   An  Item  called  PowerRing  would be in an  item  package, with a class name of  ItemPowerRing .  A  Block  called  NotDirt  would be in a  block  package, with a class name of  BlockNotDirt .  Finally, a  TileEntity  for a block called  SuperChewer  would be a  tile  or  tileentity  package, with a class name of  TileSuperChewer .   Prepending your class names with what  kind  of object they are makes it easier to figure out what a class is, or guess the class for an object.",
            "title": "Class Naming Schemes"
        },
        {
            "location": "/gettingstarted/autoupdate/",
            "text": "Forge Update Checker\n\n\nForge provides a very lightweight opt-in update-checking framework. All it does is check for updates, then show a flashing icon on the Mods button of the main menu and mod list if any mods have an available update, along with the respective changelogs. It \ndoes not\n download updates automatically.\n\n\nGetting Started\n\n\nThe first thing you want to do is specify the \nupdateJSON\n parameter in your \n@Mod\n annotation. The value of this parameter should be a valid URL pointing to an update JSON file. This file can be hosted on your own web server, or on GitHub, or wherever you want, as long as it can be reliably reached by all users of your mod.\n\n\nUpdate JSON format\n\n\nThe JSON itself has a relatively simple format, given as follows:\n\n\n{\n  \"homepage\": \"<homepage/download page for your mod>\",\n  \"<mcversion>\": {\n    \"<modversion>\": \"<changelog for this version>\", \n    // List all versions of your mod for the given Minecraft version, along with their changelogs\n    ...\n  },\n  ...\n  \"promos\": {\n    \"<mcversion>-latest\": \"<modversion>\",\n    // Declare the latest \"bleeding-edge\" version of your mod for the given Minecraft version\n    \"<mcversion>-recommended\": \"<modversion>\",\n    // Declare the latest \"stable\" version of your mod for the given Minecraft version\n    ...\n  }\n}\n\n\n\n\nThis is fairly self-explanatory, but some notes:\n\n\n\n\nThe link under \nhomepage\n is the link the user will be shown when the mod is outdated.\n\n\nForge uses an internal algorithm to determine whether one version String of your mod is \u201cnewer\u201d than another. Most versioning schemes should be compatible, but see the \nComparableVersion\n class if you are concerned about whether your scheme is supported. Adherence to \nsemantic versioning\n is highly recommended.\n\n\nThe changelog string can be separated into lines using \n\\n\n. Some prefer to include a abbreviated changelog, then link to an external site that provides a full listing of changes.\n\n\nManually inputting data can be chore. You can configure your \nbuild.gradle\n to automatically update this file when building a release, as Groovy has native JSON parsing support. Doing this is left as an exercise to the reader.\n\n\n\n\nTwo concrete examples can be seen here for \nCharset\n and \nBotania Unofficial\n.",
            "title": "Forge Update Checker"
        },
        {
            "location": "/gettingstarted/autoupdate/#forge-update-checker",
            "text": "Forge provides a very lightweight opt-in update-checking framework. All it does is check for updates, then show a flashing icon on the Mods button of the main menu and mod list if any mods have an available update, along with the respective changelogs. It  does not  download updates automatically.",
            "title": "Forge Update Checker"
        },
        {
            "location": "/gettingstarted/autoupdate/#getting-started",
            "text": "The first thing you want to do is specify the  updateJSON  parameter in your  @Mod  annotation. The value of this parameter should be a valid URL pointing to an update JSON file. This file can be hosted on your own web server, or on GitHub, or wherever you want, as long as it can be reliably reached by all users of your mod.",
            "title": "Getting Started"
        },
        {
            "location": "/gettingstarted/autoupdate/#update-json-format",
            "text": "The JSON itself has a relatively simple format, given as follows:  {\n  \"homepage\": \"<homepage/download page for your mod>\",\n  \"<mcversion>\": {\n    \"<modversion>\": \"<changelog for this version>\", \n    // List all versions of your mod for the given Minecraft version, along with their changelogs\n    ...\n  },\n  ...\n  \"promos\": {\n    \"<mcversion>-latest\": \"<modversion>\",\n    // Declare the latest \"bleeding-edge\" version of your mod for the given Minecraft version\n    \"<mcversion>-recommended\": \"<modversion>\",\n    // Declare the latest \"stable\" version of your mod for the given Minecraft version\n    ...\n  }\n}  This is fairly self-explanatory, but some notes:   The link under  homepage  is the link the user will be shown when the mod is outdated.  Forge uses an internal algorithm to determine whether one version String of your mod is \u201cnewer\u201d than another. Most versioning schemes should be compatible, but see the  ComparableVersion  class if you are concerned about whether your scheme is supported. Adherence to  semantic versioning  is highly recommended.  The changelog string can be separated into lines using  \\n . Some prefer to include a abbreviated changelog, then link to an external site that provides a full listing of changes.  Manually inputting data can be chore. You can configure your  build.gradle  to automatically update this file when building a release, as Groovy has native JSON parsing support. Doing this is left as an exercise to the reader.   Two concrete examples can be seen here for  Charset  and  Botania Unofficial .",
            "title": "Update JSON format"
        },
        {
            "location": "/concepts/sides/",
            "text": "Sides in Minecraft\n\n\nA very important concept to understand when modding Minecraft are the two sides: \nclient\n and \nserver\n. There are many, many common misconceptions and mistakes regarding siding, which can lead to bugs that might not crash the game, but can rather have unintended and often unpredictable effects.\n\n\nDifferent Kinds of Sides\n\n\nWhen we say \u201cclient\u201d or \u201cserver\u201d, it usually follows with a fairly intuitive understanding of what part of the game we\u2019re talking about. After all, a client is what the user interacts with, and a server is where the user connects for a multiplayer game. Easy, right?\n\n\nAs it turns out, there can be some ambiguity even with two such terms. Here we disambiguate the four possible meanings of \u201cclient\u201d and \u201cserver\u201d:\n\n\n\n\nPhysical client - The \nphysical client\n is the entire program that runs whenever you launch Minecraft from the launcher. All threads, processes, and services that run during the game\u2019s graphical, interactable lifetime are part of the physical client.\n\n\nPhysical server - Often known as the dedicated server, the \nphysical server\n is the entire program that runs whenever you launch any sort of \nminecraft_server.jar\n that does not bring up a playable GUI.\n\n\nLogical server - The \nlogical server\n is what runs game logic: mob spawning, weather, updating inventories, health, AI, and all other game mechanics. The logical server is present within the physical server, but is also can run inside a physical client together with a logical client, as a single player world. The logical server always runs in a thread named the \nServer Thread\n.\n\n\nLogical client - The \nlogical client\n is what accepts input from the player and relays it to the logical server. In addition, it also receives information from the logical server and makes it available graphically to the player. The logical client runs in the \nClient Thread\n, though often several other threads are spawned to handle things like audio and chunk render batching.\n\n\n\n\nPerforming Side-Specific Operations\n\n\nworld.isRemote\n\n\nThis boolean check will be your most used way to check sides. Querying this field on a \nWorld\n object establishes the  \nlogical\n side the world belongs to. That is, if this field is \ntrue\n, the world is currently running on the logical client. If the field is \nfalse\n, the world is running on the logical server. It follows that the physical server will always contain \nfalse\n in this field, but we cannot assume that \nfalse\n implies a physical server, since this field can also be \nfalse\n for the logical server inside a physical client (in other words, a single player world).\n\n\nUse this check whenever you need to determine if game logic and other mechanics should be run. For example, if you want to damage the player every time they click your block, or have your machine process dirt into diamonds, you should only do so after ensuring \nworld.isRemote\n is \nfalse\n. Applying game logic to the logical client can cause desynchronization (ghost entities, desynchronized stats, etc.) in the lightest case, and crashes in the worst case.\n\n\nThis check should be used as your go-to default. Aside from proxies, rarely will you need the other ways of determining side and adjusting behavior.\n\n\n@SidedProxy\n\n\nConsidering the use of a single \u201cuniversal\u201d jar for client and server mods, and the separation of the physical sides into two jars, an important question comes to mind: How do we use code that is only present on one physical side? All code in \nnet.minecraft.client\n is only present on the physical client, and all code in \nnet.minecraft.server.dedicated\n is only present on the physical server. If any class you write references those names in any way, they will crash the game when that respective class is loaded in an environment where those names do not exist. A very common mistake in beginners is to call \nMinecraft.getMinecraft().<doStuff>()\n in block or tile entity classes, which will crash any physical server as soon as the class is loaded.\n\n\nHow do we resolve this? Luckily, FML provides us with a \n@SidedProxy\n annotation. We supply it the names of two classes (one for \nserverSide\n, one for \nclientSide\n), and decorate a field with this annotation. When the mod starts, FML will instantiate one of the two classes based on the \nphysical\n side.\n\n\n\n\nNote\n\n\nIt is important to understand that FML picks the proxy to instantiate based on the \nphysical\n side. A single player world (logical server + logical client within a physical client) will still have a proxy of the type you specify in \nclientSide\n!\n\n\n\n\nA common use case is to register renderers and models, something which must be called from the main initialization methods \npreInit\n, \ninit\n, or \npostInit\n. However, many rendering related classes and registries are not present on the physical server and may crash it. Therefore, we put these actions into the client proxy, ensuring that they will always execute for the physical client.\n\n\nRemember that both of your specified proxies must have a type that is assignable into the field you annotate with \n@SidedProxy\n. A common pattern, but by no means the only strategy, is to have an interface \nIProxy\n as the field type, and then have two implementations, \nClientProxy\n and \nServerProxy\n for the two corresponding physical sides.\n\n\ngetEffectiveSide\n\n\nFMLCommonHandler.getEffectiveSide()\n can be called in order to retrieve the \nlogical\n side when you do not have access to a \nWorld\n object to check \nisRemote\n. It \nguesses\n which logical side you are on by looking at the name of the currently running thread. Because it is a guess, this method should only be used when other options have been exhausted. In nearly every case, you should prefer checking \nworld.isRemote\n to this method call.\n\n\ngetSide\n and \n@SideOnly\n\n\nFMLCommonHandler.getSide()\n can be called in order to retrieve the \nphysical\n side your code is running on. Since it is determined at startup, it does not rely on guessing to return its result. The number of use cases for this method is limited, however.\n\n\nAnnotating a method or field with the \n@SideOnly\n annotation indicates to the loader that the respective member should be completely stripped out of the definition not on the specified \nphysical\n side. Usually, these are only seen when browsing through the decompiled Minecraft code, indicating methods that the Mojang obfuscator stripped out. There is little to no reason for using this annotation directly. Only use it if you are overriding a vanilla method that already has \n@SideOnly\n defined. In most other cases where you need to dispatch behavior based on physical sides, use \n@SidedProxy\n or a check on \ngetSide()\n instead.\n\n\nCommon Mistakes\n\n\nReaching Across Logical Sides\n\n\nWhenever you want to send information from one logical side to another, you must \nalways\n use network packets. It is incredibly tempting, when in a single player scenario, to directly transfer data from the logical server to the logical client.\n\n\nThis is actually very commonly inadvertently done through static fields. Since the logical client and logical server share the same JVM in a single player scenario, both threads writing to and reading from static fields will cause all sorts of race conditions and the classical issues associated with threading.\n\n\nThis mistake can also be made explicitly by accessing physical client-only classes such as \nMinecraft\n from common code that runs or can run on the logical server. This mistake is easy to miss for beginners, who debug in a physical client. The code will work there, but will immediately crash on a physical server.",
            "title": "Sides"
        },
        {
            "location": "/concepts/sides/#sides-in-minecraft",
            "text": "A very important concept to understand when modding Minecraft are the two sides:  client  and  server . There are many, many common misconceptions and mistakes regarding siding, which can lead to bugs that might not crash the game, but can rather have unintended and often unpredictable effects.",
            "title": "Sides in Minecraft"
        },
        {
            "location": "/concepts/sides/#different-kinds-of-sides",
            "text": "When we say \u201cclient\u201d or \u201cserver\u201d, it usually follows with a fairly intuitive understanding of what part of the game we\u2019re talking about. After all, a client is what the user interacts with, and a server is where the user connects for a multiplayer game. Easy, right?  As it turns out, there can be some ambiguity even with two such terms. Here we disambiguate the four possible meanings of \u201cclient\u201d and \u201cserver\u201d:   Physical client - The  physical client  is the entire program that runs whenever you launch Minecraft from the launcher. All threads, processes, and services that run during the game\u2019s graphical, interactable lifetime are part of the physical client.  Physical server - Often known as the dedicated server, the  physical server  is the entire program that runs whenever you launch any sort of  minecraft_server.jar  that does not bring up a playable GUI.  Logical server - The  logical server  is what runs game logic: mob spawning, weather, updating inventories, health, AI, and all other game mechanics. The logical server is present within the physical server, but is also can run inside a physical client together with a logical client, as a single player world. The logical server always runs in a thread named the  Server Thread .  Logical client - The  logical client  is what accepts input from the player and relays it to the logical server. In addition, it also receives information from the logical server and makes it available graphically to the player. The logical client runs in the  Client Thread , though often several other threads are spawned to handle things like audio and chunk render batching.",
            "title": "Different Kinds of Sides"
        },
        {
            "location": "/concepts/sides/#performing-side-specific-operations",
            "text": "",
            "title": "Performing Side-Specific Operations"
        },
        {
            "location": "/concepts/sides/#worldisremote",
            "text": "This boolean check will be your most used way to check sides. Querying this field on a  World  object establishes the   logical  side the world belongs to. That is, if this field is  true , the world is currently running on the logical client. If the field is  false , the world is running on the logical server. It follows that the physical server will always contain  false  in this field, but we cannot assume that  false  implies a physical server, since this field can also be  false  for the logical server inside a physical client (in other words, a single player world).  Use this check whenever you need to determine if game logic and other mechanics should be run. For example, if you want to damage the player every time they click your block, or have your machine process dirt into diamonds, you should only do so after ensuring  world.isRemote  is  false . Applying game logic to the logical client can cause desynchronization (ghost entities, desynchronized stats, etc.) in the lightest case, and crashes in the worst case.  This check should be used as your go-to default. Aside from proxies, rarely will you need the other ways of determining side and adjusting behavior.",
            "title": "world.isRemote"
        },
        {
            "location": "/concepts/sides/#sidedproxy",
            "text": "Considering the use of a single \u201cuniversal\u201d jar for client and server mods, and the separation of the physical sides into two jars, an important question comes to mind: How do we use code that is only present on one physical side? All code in  net.minecraft.client  is only present on the physical client, and all code in  net.minecraft.server.dedicated  is only present on the physical server. If any class you write references those names in any way, they will crash the game when that respective class is loaded in an environment where those names do not exist. A very common mistake in beginners is to call  Minecraft.getMinecraft().<doStuff>()  in block or tile entity classes, which will crash any physical server as soon as the class is loaded.  How do we resolve this? Luckily, FML provides us with a  @SidedProxy  annotation. We supply it the names of two classes (one for  serverSide , one for  clientSide ), and decorate a field with this annotation. When the mod starts, FML will instantiate one of the two classes based on the  physical  side.   Note  It is important to understand that FML picks the proxy to instantiate based on the  physical  side. A single player world (logical server + logical client within a physical client) will still have a proxy of the type you specify in  clientSide !   A common use case is to register renderers and models, something which must be called from the main initialization methods  preInit ,  init , or  postInit . However, many rendering related classes and registries are not present on the physical server and may crash it. Therefore, we put these actions into the client proxy, ensuring that they will always execute for the physical client.  Remember that both of your specified proxies must have a type that is assignable into the field you annotate with  @SidedProxy . A common pattern, but by no means the only strategy, is to have an interface  IProxy  as the field type, and then have two implementations,  ClientProxy  and  ServerProxy  for the two corresponding physical sides.",
            "title": "@SidedProxy"
        },
        {
            "location": "/concepts/sides/#geteffectiveside",
            "text": "FMLCommonHandler.getEffectiveSide()  can be called in order to retrieve the  logical  side when you do not have access to a  World  object to check  isRemote . It  guesses  which logical side you are on by looking at the name of the currently running thread. Because it is a guess, this method should only be used when other options have been exhausted. In nearly every case, you should prefer checking  world.isRemote  to this method call.",
            "title": "getEffectiveSide"
        },
        {
            "location": "/concepts/sides/#getside-and-sideonly",
            "text": "FMLCommonHandler.getSide()  can be called in order to retrieve the  physical  side your code is running on. Since it is determined at startup, it does not rely on guessing to return its result. The number of use cases for this method is limited, however.  Annotating a method or field with the  @SideOnly  annotation indicates to the loader that the respective member should be completely stripped out of the definition not on the specified  physical  side. Usually, these are only seen when browsing through the decompiled Minecraft code, indicating methods that the Mojang obfuscator stripped out. There is little to no reason for using this annotation directly. Only use it if you are overriding a vanilla method that already has  @SideOnly  defined. In most other cases where you need to dispatch behavior based on physical sides, use  @SidedProxy  or a check on  getSide()  instead.",
            "title": "getSide and @SideOnly"
        },
        {
            "location": "/concepts/sides/#common-mistakes",
            "text": "",
            "title": "Common Mistakes"
        },
        {
            "location": "/concepts/sides/#reaching-across-logical-sides",
            "text": "Whenever you want to send information from one logical side to another, you must  always  use network packets. It is incredibly tempting, when in a single player scenario, to directly transfer data from the logical server to the logical client.  This is actually very commonly inadvertently done through static fields. Since the logical client and logical server share the same JVM in a single player scenario, both threads writing to and reading from static fields will cause all sorts of race conditions and the classical issues associated with threading.  This mistake can also be made explicitly by accessing physical client-only classes such as  Minecraft  from common code that runs or can run on the logical server. This mistake is easy to miss for beginners, who debug in a physical client. The code will work there, but will immediately crash on a physical server.",
            "title": "Reaching Across Logical Sides"
        },
        {
            "location": "/concepts/registries/",
            "text": "Registries\n\n\nRegistration is the process of taking the objects of a mod (items, blocks, sounds, etc.) and making them known to the game. Registering things is important, as without registration the game will simply not know about these objects in a mod and will exhibit great amounts of unexplainable behavior (and probably crash).\n\n\nMost things that require registration in the game are handled by the Forge registries. A registry is a simple object similar to a map that assigns values to keys. Additionally, they automatically assign integer IDs to values. Forge uses registries with \nResourceLocation\n keys to register objects, which are of type \nIForgeRegistryEntry\n. This allows the RL to act like a \u201cregistry name\u201d for the object. The registry name for an object may be accessed with \nget\n/\nsetRegistryName\n. The setter can only ever be called once, and calling it twice results in an exception. Every type of registrable object has its own registry, and names in two different registries will not collide. (E.g. there\u2019s a registry for \nBlock\ns, and a registry for \nItem\ns, and a \nBlock\n and an \nItem\n may be registered with the same name \nmod:example\n without colliding. However, if two blocks were registered with that name, an exception would be thrown.) The default implementation of \nIForgeRegistryEntry\n (\nIForgeRegistryEntry.Impl\n) also provides two convenience implementations of \nsetRegistryName\n: one where the parameter is a single string, and one where there are two string parameters. The overload that takes a single string checks whether the input contains a \n:\n (i.e. it checks whether the passed in stringified \nResourceLocation\n has a domain), and if it doesn\u2019t it uses the current modid as the resource domain. The two argument overload simply constructs the registry name using the \nmodID\n as the domain and \nname\n as the path.\n\n\nThere also exists the \u201cregistry registry\u201d, a registry that registers other registries. This registry registers registries with \nResourceLocation\n names and secondary \nClass\n keys. This allows one to look up the registry that registers a certain class (e.g. one can look up \nBlock.class\n in the registry registry with \nGameRegistry.findRegistry\n to get the registry that registers blocks).\n\n\nRegistering Things\n\n\nThe recommended way to register things is through the \nRegistryEvent\ns. In \nRegistryEvent.NewRegistry\n, registries should be created. Later, \nRegistryEvent.Register\n is fired once for each registered registry. Because \nRegister\n is a generic event, the event handler should set the type parameter to the type of the object being registered. The event will contain the registry to register things to (\ngetRegistry\n), and things may be registered with \nregister\n (or \nregisterAll\n) on the registry. Here\u2019s an example of an event handler that registers blocks:\n\n\n@SubscribeEvent\npublic void registerBlocks(RegistryEvent.Register<Block> event) {\n    event.getRegistry().registerAll(block1, block2, ...);\n}\n\n\n\n\nThe order in which \nRegistryEvent.Register\n events fire is arbitrary, with the exception that \nBlock\n will \nalways\n fire first, and \nItem\n will \nalways\n fire second, right after \nBlock\n. After the \nRegister<Block>\n event has fired, all \nObjectHolder\n annotations are refreshed, and after \nRegister<Item>\n has fired they are refreshed again. They are refreshed for a third time after \nall\n of the other \nRegister\n events have fired.\n\n\n\n\nImportant\n\n\nThese events are fired \nbefore\n preinit. This means that \n@Mod.EventBusSubscriber\n (or \nMinecraftForge.EVENT_BUS.register\n in the \n@Mod\n class\u2019s constructor for e.g. Scala mods which do not support \nstatic\n) should be used to register the event handler before preinit.\n\n\n\n\nThere is another, older way of registering objects into registries, using \nGameRegistry.register\n. Anytime something suggests using this method, it should be replaced with an event handler for the appropriate registry event. This method simply finds the registry corresponding to an \nIForgeRegistryEntry\n with \nIForgeRegistryEntry::getRegistryType\n, and then registers the object to the registry. There is also a convenience overload that takes an \nIForgeRegistryEntry\n (\nifre\n) and an RL, which is equivalent to \nGameRegistry.register(ifre.setRegistryName(rl))\n.\n\n\nCreating Registries\n\n\nRegistries are not only for Forge. Any mod can create their own registries, and any mod can register things to registries from any other mod. Registries are created by using \nRegistryBuilder\n. This class takes certain parameters for the registry it will generate, such as the name. the \nClass\n of it\u2019s values, and various callbacks for when the registry is changed. Upon calling \nRegistryBuilder::create\n, the registry is built, registered to the registry registry, and returned to the caller.\n\n\nInjecting Registry Values Into Fields\n\n\nIt is possible to have Forge inject values from registries into \npublic static final\n fields of classes. This is done by annotating classes and fields with \n@ObjectHolder\n. If a class has this annotation, all the \npublic static final\n fields within are taken to be object holders too, and the value of the annotation is the domain of the holder (i.e. every field uses it as the default domain for the registry name of the object to inject). If a field has this annotation, and the value does not contain a domain, the domain is chosen from the surrounding class\u2019s \n@ObjectHolder\n annotation. If the class is not annotated in this situation, the field is ignored with a warning. If it does contain a domain, then the object to inject into the field is the object with that name. If the class has the annotation and one of the \npublic static final\n fields does not, then the resource path of the object\u2019s name is taken to be the field\u2019s name. The type of the registry is taken from the type of the field.\n\n\n\n\nNote\n\n\nIf an object is not found, either because the object itself hasn\u2019t been registered or because the registry does not exist, a debug message is logged and the field is left unchanged.\n\n\n\n\nAs these rules are rather complicated, here are some examples:\n\n\n@ObjectHolder(\"minecraft\") // Resource domain \"minecraft\"\nclass AnnotatedHolder {\n    public static final Block diamond_block = null; // public static final is required.\n                                                    // Type Block means that the Block registry will be queried.\n                                                    // diamond_block is the field name, and as the field is not annotated it is taken to be the resource path.\n                                                    // As there is no explicit domain, \"minecraft\" is inherited from the class.\n                                                    // Object to be injected: \"minecraft:diamond_block\" from the Block registry.\n\n    @ObjectHolder(\"ender_eye\")\n    public static final Item eye_of_ender = null;   // Type Item means that the Item registry will be queried.\n                                                    // As the annotation has the value \"ender_eye\", that overrides the field's name.\n                                                    // As the domain is not explicit, \"minecraft\" is inherited from the class.\n                                                    // Object to be injected: \"minecraft:ender_eye\" from the Item registry.\n\n    @ObjectHolder(\"neomagicae:coffeinum\")\n    public static final ManaType coffeinum = null;  // Type ManaType means that the ManaType registry will be queried. This is obviously a registry made by a mod.\n                                                    // As the annotation has the value \"neomagicae:coffeinum\", that overrides the field's name.\n                                                    // The domain is explicit, and is \"neomagicae\", overriding the class's \"minecraft\" default.\n                                                    // Object to be injected: \"neomagicae:coffeinum\" from the ManaType registry.\n\n    public static final Item ENDER_PEARL = null;    // Note that the actual name is \"minecraft:ender_pearl\", not \"minecraft:ENDER_PEARL\".\n                                                    // Therefore, THIS WILL FAIL. The field has to be lowercased or annotated.\n}\n\nclass UnannotatedHolder { // Note lack of annotation on this class.\n    @ObjectHolder(\"minecraft:flame\")\n    public static final Enchantment flame = null;   // No annotation on the class means that there is no preset domain to inherit.\n                                                    // Field annotation supplies all the information for the object.\n                                                    // Object to be injected: \"minecraft:flame\" from the Enchantment registry.\n\n    public static final Biome ice_flat = null;      // No annotation on the class or the field.\n                                                    // Therefore this just gets ignored.\n\n    @ObjectHolder(\"levitation\")\n    public static final Potion levitation = null;   // No resource domain in annotation, and no default specified by class annotation.\n                                                    // Therefore, THIS WILL FAIL. The field annotation needs a domain, or the class needs an annotation.\n}",
            "title": "Registries"
        },
        {
            "location": "/concepts/registries/#registries",
            "text": "Registration is the process of taking the objects of a mod (items, blocks, sounds, etc.) and making them known to the game. Registering things is important, as without registration the game will simply not know about these objects in a mod and will exhibit great amounts of unexplainable behavior (and probably crash).  Most things that require registration in the game are handled by the Forge registries. A registry is a simple object similar to a map that assigns values to keys. Additionally, they automatically assign integer IDs to values. Forge uses registries with  ResourceLocation  keys to register objects, which are of type  IForgeRegistryEntry . This allows the RL to act like a \u201cregistry name\u201d for the object. The registry name for an object may be accessed with  get / setRegistryName . The setter can only ever be called once, and calling it twice results in an exception. Every type of registrable object has its own registry, and names in two different registries will not collide. (E.g. there\u2019s a registry for  Block s, and a registry for  Item s, and a  Block  and an  Item  may be registered with the same name  mod:example  without colliding. However, if two blocks were registered with that name, an exception would be thrown.) The default implementation of  IForgeRegistryEntry  ( IForgeRegistryEntry.Impl ) also provides two convenience implementations of  setRegistryName : one where the parameter is a single string, and one where there are two string parameters. The overload that takes a single string checks whether the input contains a  :  (i.e. it checks whether the passed in stringified  ResourceLocation  has a domain), and if it doesn\u2019t it uses the current modid as the resource domain. The two argument overload simply constructs the registry name using the  modID  as the domain and  name  as the path.  There also exists the \u201cregistry registry\u201d, a registry that registers other registries. This registry registers registries with  ResourceLocation  names and secondary  Class  keys. This allows one to look up the registry that registers a certain class (e.g. one can look up  Block.class  in the registry registry with  GameRegistry.findRegistry  to get the registry that registers blocks).",
            "title": "Registries"
        },
        {
            "location": "/concepts/registries/#registering-things",
            "text": "The recommended way to register things is through the  RegistryEvent s. In  RegistryEvent.NewRegistry , registries should be created. Later,  RegistryEvent.Register  is fired once for each registered registry. Because  Register  is a generic event, the event handler should set the type parameter to the type of the object being registered. The event will contain the registry to register things to ( getRegistry ), and things may be registered with  register  (or  registerAll ) on the registry. Here\u2019s an example of an event handler that registers blocks:  @SubscribeEvent\npublic void registerBlocks(RegistryEvent.Register<Block> event) {\n    event.getRegistry().registerAll(block1, block2, ...);\n}  The order in which  RegistryEvent.Register  events fire is arbitrary, with the exception that  Block  will  always  fire first, and  Item  will  always  fire second, right after  Block . After the  Register<Block>  event has fired, all  ObjectHolder  annotations are refreshed, and after  Register<Item>  has fired they are refreshed again. They are refreshed for a third time after  all  of the other  Register  events have fired.   Important  These events are fired  before  preinit. This means that  @Mod.EventBusSubscriber  (or  MinecraftForge.EVENT_BUS.register  in the  @Mod  class\u2019s constructor for e.g. Scala mods which do not support  static ) should be used to register the event handler before preinit.   There is another, older way of registering objects into registries, using  GameRegistry.register . Anytime something suggests using this method, it should be replaced with an event handler for the appropriate registry event. This method simply finds the registry corresponding to an  IForgeRegistryEntry  with  IForgeRegistryEntry::getRegistryType , and then registers the object to the registry. There is also a convenience overload that takes an  IForgeRegistryEntry  ( ifre ) and an RL, which is equivalent to  GameRegistry.register(ifre.setRegistryName(rl)) .",
            "title": "Registering Things"
        },
        {
            "location": "/concepts/registries/#creating-registries",
            "text": "Registries are not only for Forge. Any mod can create their own registries, and any mod can register things to registries from any other mod. Registries are created by using  RegistryBuilder . This class takes certain parameters for the registry it will generate, such as the name. the  Class  of it\u2019s values, and various callbacks for when the registry is changed. Upon calling  RegistryBuilder::create , the registry is built, registered to the registry registry, and returned to the caller.",
            "title": "Creating Registries"
        },
        {
            "location": "/concepts/registries/#injecting-registry-values-into-fields",
            "text": "It is possible to have Forge inject values from registries into  public static final  fields of classes. This is done by annotating classes and fields with  @ObjectHolder . If a class has this annotation, all the  public static final  fields within are taken to be object holders too, and the value of the annotation is the domain of the holder (i.e. every field uses it as the default domain for the registry name of the object to inject). If a field has this annotation, and the value does not contain a domain, the domain is chosen from the surrounding class\u2019s  @ObjectHolder  annotation. If the class is not annotated in this situation, the field is ignored with a warning. If it does contain a domain, then the object to inject into the field is the object with that name. If the class has the annotation and one of the  public static final  fields does not, then the resource path of the object\u2019s name is taken to be the field\u2019s name. The type of the registry is taken from the type of the field.   Note  If an object is not found, either because the object itself hasn\u2019t been registered or because the registry does not exist, a debug message is logged and the field is left unchanged.   As these rules are rather complicated, here are some examples:  @ObjectHolder(\"minecraft\") // Resource domain \"minecraft\"\nclass AnnotatedHolder {\n    public static final Block diamond_block = null; // public static final is required.\n                                                    // Type Block means that the Block registry will be queried.\n                                                    // diamond_block is the field name, and as the field is not annotated it is taken to be the resource path.\n                                                    // As there is no explicit domain, \"minecraft\" is inherited from the class.\n                                                    // Object to be injected: \"minecraft:diamond_block\" from the Block registry.\n\n    @ObjectHolder(\"ender_eye\")\n    public static final Item eye_of_ender = null;   // Type Item means that the Item registry will be queried.\n                                                    // As the annotation has the value \"ender_eye\", that overrides the field's name.\n                                                    // As the domain is not explicit, \"minecraft\" is inherited from the class.\n                                                    // Object to be injected: \"minecraft:ender_eye\" from the Item registry.\n\n    @ObjectHolder(\"neomagicae:coffeinum\")\n    public static final ManaType coffeinum = null;  // Type ManaType means that the ManaType registry will be queried. This is obviously a registry made by a mod.\n                                                    // As the annotation has the value \"neomagicae:coffeinum\", that overrides the field's name.\n                                                    // The domain is explicit, and is \"neomagicae\", overriding the class's \"minecraft\" default.\n                                                    // Object to be injected: \"neomagicae:coffeinum\" from the ManaType registry.\n\n    public static final Item ENDER_PEARL = null;    // Note that the actual name is \"minecraft:ender_pearl\", not \"minecraft:ENDER_PEARL\".\n                                                    // Therefore, THIS WILL FAIL. The field has to be lowercased or annotated.\n}\n\nclass UnannotatedHolder { // Note lack of annotation on this class.\n    @ObjectHolder(\"minecraft:flame\")\n    public static final Enchantment flame = null;   // No annotation on the class means that there is no preset domain to inherit.\n                                                    // Field annotation supplies all the information for the object.\n                                                    // Object to be injected: \"minecraft:flame\" from the Enchantment registry.\n\n    public static final Biome ice_flat = null;      // No annotation on the class or the field.\n                                                    // Therefore this just gets ignored.\n\n    @ObjectHolder(\"levitation\")\n    public static final Potion levitation = null;   // No resource domain in annotation, and no default specified by class annotation.\n                                                    // Therefore, THIS WILL FAIL. The field annotation needs a domain, or the class needs an annotation.\n}",
            "title": "Injecting Registry Values Into Fields"
        },
        {
            "location": "/blocks/blocks/",
            "text": "Blocks\n\n\nBlocks are, obviously, essential to the Minecraft world. They make up all of the terrain, structures, and machines. Chances are if you are interested in making a mod, then you will want to add some blocks. This page will guide you through the creation of blocks, and some of the things you can do with them.\n\n\nCreating a Block\n\n\nBasic Blocks\n\n\nFor simple blocks, which need no special functionality (think cobblestone, wood planks, etc.), a custom class is not necessary. By simply instantiating the \nBlock\n class and calling some of the many setters, one can create many different types of blocks. For instance:\n\n\n\n\nsetHardness\n - Controls the time it takes to break the block. It is an arbitrary value. For reference, stone has a hardness of 1.5, and dirt 0.5. If the block should be unbreakable, a convenience method \nsetBlockUnbreakable\n is provided.\n\n\nsetResistance\n - Controls the explosion resistance of the block. This is separate from hardness, but \nsetHardness\n will also set the resistance to 5 times the hardness value, if the resistance is any lower than this value.\n\n\nsetSoundType\n - Controls the sound the block makes when it is punched, broken, or placed. Requires a \nSoundType\n argument, see the \nsounds\n page for more details.\n\n\nsetLightLevel\n - Controls the light emission of the block. \nNote:\n This method takes a value from zero to one, not zero to fifteen. To calculate this value, take the light level you wish your block to emit and divide by 16. For instance a block which emits level 5 light should pass \n5 / 16f\n to this method.\n\n\nsetLightOpacity\n - Controls the amount light passing through this block will be dimmed. Unlike \nsetLightLevel\n this value is on a scale from zero to 15. For example, setting this to \n3\n will lower light by 3 levels every time it passes through this type of block.\n\n\nsetUnlocalizedName\n - Mostly self explanatory, sets the unlocalized name of the block. This name will be prepended with \u201ctile.\u201d and appended with \u201c.name\u201d for localization purposes. For instance \nsetUnlocalizedName(\"foo\")\n will cause the block\u2019s actual localization key to be \u201ctile.foo.name\u201d. For more advanced localization control, a custom Item will be needed. We\u2019ll get into this more later.\n\n\nsetCreativeTab\n - Controls which creative tab this block will fall under. This must be called if the block should be shown in the creative menu. Tab options can be found in the \nCreativeTabs\n class.\n\n\n\n\nAll these methods are \nchainable\n which means you can call them in series. See \nBlock#registerBlocks\n for examples of this.\n\n\nAdvanced Blocks\n\n\nOf course, the above only allows for extremely basic blocks. If you want to add functionality, like player interaction, a custom class is required. However, the \nBlock\n class has many methods and unfortunately not every single one can be documented here. See the rest of the pages in this section for things you can do with blocks.\n\n\nRegistering a Block\n\n\nBlocks must be \nregistered\n to function.\n\n\n\n\nImportant\n\n\nA block in the world and a \u201cblock\u201d in an inventory are very different things. A block in the world is represented by an \nIBlockState\n, and its behavior defined by an instance of \nBlock\n. Meanwhile, an item in an inventory is an \nItemStack\n, controlled by an \nItem\n. As a bridge between the different worlds of \nBlock\n and \nItem\n, there exists the class \nItemBlock\n. \nItemBlock\n is a subclass of \nItem\n that has a field \nblock\n that holds a reference to the \nBlock\n it represents. \nItemBlock\n defines some of the behavior of a \u201cblock\u201d as an item, like how a right click places the block. It\u2019s possible to have a \nBlock\n without an \nItemBlock\n. (E.g. \nminecraft:water\n exists a block, but not an item. It is therefore impossible to hold it in an inventory as one.)\n\n\nWhen a block is registered, \nonly\n a block is registered. The block does not automatically have an \nItemBlock\n. To create a basic \nItemBlock\n for a block one should use \nnew ItemBlock(block).setRegistryName(block.getRegistryName())\n. The unlocalized name is the same as the block\u2019s. Custom subclasses of \nItemBlock\n may be used as well. Once an \nItemBlock\n has been registered for a block, \nItem.getItemFromBlock\n can be used to retrieve it. \nItem.getItemFromBlock\n will return \nnull\n if there is no ItemBlock for the Block, so if you are not certain that there is an ItemBlock for the Block you are using, check for null.\n\n\n\n\nFurther Reading\n\n\nFor information about block properties, such as those used for vanilla blocks like wood types, fences, walls, and many more, see the section on \nblockstates\n.",
            "title": "Home"
        },
        {
            "location": "/blocks/blocks/#blocks",
            "text": "Blocks are, obviously, essential to the Minecraft world. They make up all of the terrain, structures, and machines. Chances are if you are interested in making a mod, then you will want to add some blocks. This page will guide you through the creation of blocks, and some of the things you can do with them.",
            "title": "Blocks"
        },
        {
            "location": "/blocks/blocks/#creating-a-block",
            "text": "",
            "title": "Creating a Block"
        },
        {
            "location": "/blocks/blocks/#basic-blocks",
            "text": "For simple blocks, which need no special functionality (think cobblestone, wood planks, etc.), a custom class is not necessary. By simply instantiating the  Block  class and calling some of the many setters, one can create many different types of blocks. For instance:   setHardness  - Controls the time it takes to break the block. It is an arbitrary value. For reference, stone has a hardness of 1.5, and dirt 0.5. If the block should be unbreakable, a convenience method  setBlockUnbreakable  is provided.  setResistance  - Controls the explosion resistance of the block. This is separate from hardness, but  setHardness  will also set the resistance to 5 times the hardness value, if the resistance is any lower than this value.  setSoundType  - Controls the sound the block makes when it is punched, broken, or placed. Requires a  SoundType  argument, see the  sounds  page for more details.  setLightLevel  - Controls the light emission of the block.  Note:  This method takes a value from zero to one, not zero to fifteen. To calculate this value, take the light level you wish your block to emit and divide by 16. For instance a block which emits level 5 light should pass  5 / 16f  to this method.  setLightOpacity  - Controls the amount light passing through this block will be dimmed. Unlike  setLightLevel  this value is on a scale from zero to 15. For example, setting this to  3  will lower light by 3 levels every time it passes through this type of block.  setUnlocalizedName  - Mostly self explanatory, sets the unlocalized name of the block. This name will be prepended with \u201ctile.\u201d and appended with \u201c.name\u201d for localization purposes. For instance  setUnlocalizedName(\"foo\")  will cause the block\u2019s actual localization key to be \u201ctile.foo.name\u201d. For more advanced localization control, a custom Item will be needed. We\u2019ll get into this more later.  setCreativeTab  - Controls which creative tab this block will fall under. This must be called if the block should be shown in the creative menu. Tab options can be found in the  CreativeTabs  class.   All these methods are  chainable  which means you can call them in series. See  Block#registerBlocks  for examples of this.",
            "title": "Basic Blocks"
        },
        {
            "location": "/blocks/blocks/#advanced-blocks",
            "text": "Of course, the above only allows for extremely basic blocks. If you want to add functionality, like player interaction, a custom class is required. However, the  Block  class has many methods and unfortunately not every single one can be documented here. See the rest of the pages in this section for things you can do with blocks.",
            "title": "Advanced Blocks"
        },
        {
            "location": "/blocks/blocks/#registering-a-block",
            "text": "Blocks must be  registered  to function.   Important  A block in the world and a \u201cblock\u201d in an inventory are very different things. A block in the world is represented by an  IBlockState , and its behavior defined by an instance of  Block . Meanwhile, an item in an inventory is an  ItemStack , controlled by an  Item . As a bridge between the different worlds of  Block  and  Item , there exists the class  ItemBlock .  ItemBlock  is a subclass of  Item  that has a field  block  that holds a reference to the  Block  it represents.  ItemBlock  defines some of the behavior of a \u201cblock\u201d as an item, like how a right click places the block. It\u2019s possible to have a  Block  without an  ItemBlock . (E.g.  minecraft:water  exists a block, but not an item. It is therefore impossible to hold it in an inventory as one.)  When a block is registered,  only  a block is registered. The block does not automatically have an  ItemBlock . To create a basic  ItemBlock  for a block one should use  new ItemBlock(block).setRegistryName(block.getRegistryName()) . The unlocalized name is the same as the block\u2019s. Custom subclasses of  ItemBlock  may be used as well. Once an  ItemBlock  has been registered for a block,  Item.getItemFromBlock  can be used to retrieve it.  Item.getItemFromBlock  will return  null  if there is no ItemBlock for the Block, so if you are not certain that there is an ItemBlock for the Block you are using, check for null.",
            "title": "Registering a Block"
        },
        {
            "location": "/blocks/blocks/#further-reading",
            "text": "For information about block properties, such as those used for vanilla blocks like wood types, fences, walls, and many more, see the section on  blockstates .",
            "title": "Further Reading"
        },
        {
            "location": "/blocks/interaction/",
            "text": "Block Interaction\n\n\nThere are many different ways players (and other things) can interact with blocks, such as right clicking, left clicking, colliding, walking on, and of course mining.\n\n\nThis page will cover the basics of the most common types of interaction with blocks.\n\n\nPlayer Right Click\n\n\nSince left clicking, or \u201cpunching\u201d, a block does not generally result in any unique behavior, it is probably fair to say right clicking, or \u201cactivation\u201d, is \nthe\n most common method of interaction. And thankfully, it is also one of the simplest to handle.\n\n\nonBlockActivated\n\n\nThis is the method that controls right click behavior, and it is a rather complicated one. Here is its full signature:\n\n\npublic boolean onBlockActivated(World worldIn,\n                                BlockPos pos,\n                                IBlockState state,\n                                EntityPlayer playerIn,\n                                EnumHand hand,\n                                @Nullable ItemStack heldItem,\n                                EnumFacing side,\n                                float hitX,\n                                float hitY,\n                                float hitZ)\n\n\n\n\nThere\u2019s quite a bit to discuss here.\n\n\nParameters\n\n\nThe first few parameters are obvious, they are the current world, position, and state of the block. Next is the player that is activating the block, and the hand with which they are activating.\n\n\nThe next parameter, \nheldItem\n, is the \nItemStack\n which the player activated the block with. Note that this parameter is \n@Nullable\n meaning it can be passed as null (i.e. no item was in the hand).\n\n\n\n\nImportant\n\n\nThe ItemStack passed to this method is the one you should use for checking what was in the player\u2019s hand. Grabbing the currently held stack from the player is unreliable as it may have changed since activation.\n\n\n\n\nThe last four parameters are all related. \nside\n is obviously the side which was activated, however \nhitX\n, \nhitY\n, and \nhitZ\n are a bit less obvious. These are the coordinates of the activation on the block\u2019s bounds. They are on the range 0 to 1, and represent where exactly \u201con\u201d the block the player clicked.\n\n\nReturn Value\n\n\nWhat is this magic boolean which must be returned? Simply put this, is whether or not the method \u201cdid\u201d something. Return true if some action was performed, this will prevent further things from happening, such as item activation.\n\n\n\n\nImportant\n\n\nReturning \nfalse\n from this method on the client will prevent it being called on the server. It is common practice to just check \nworldIn.isRemote\n and return \ntrue\n, and otherwise go on to normal activation logic. Vanilla has many examples of this, such as the chest.\n\n\n\n\nUses\n\n\nThe uses for activation are literally endless. However, there are some common ones which deserve their own section.\n\n\nGUIs\n\n\nOne of the most common things to do on block activation is opening a GUI. Many blocks in vanilla behave this way, such as chests, hoppers, furnaces, and many more. More about GUIs can be found on \ntheir page\n.\n\n\nActivation\n\n\nAnother common use for activation is, well, activation. This can be something like \u201cturning on\u201d a block, or triggering it to perform some action. For instance, a block could light up when activated. A vanilla example would be buttons or levers.\n\n\n\n\nImportant\n\n\nonBlockActivated\n is called on both the client and the server, so be sure to keep the \nsidedness\n of your code in mind. Many things, like opening GUIs and modifying the world, should only be done on the server-side.\n\n\n\n\nPlayer Break/Destroy\n\n\nComing Soon\n\n\nPlayer Highlighting\n\n\nComing Soon\n\n\nEntity Collision\n\n\nComing Soon",
            "title": "Interaction"
        },
        {
            "location": "/blocks/interaction/#block-interaction",
            "text": "There are many different ways players (and other things) can interact with blocks, such as right clicking, left clicking, colliding, walking on, and of course mining.  This page will cover the basics of the most common types of interaction with blocks.",
            "title": "Block Interaction"
        },
        {
            "location": "/blocks/interaction/#player-right-click",
            "text": "Since left clicking, or \u201cpunching\u201d, a block does not generally result in any unique behavior, it is probably fair to say right clicking, or \u201cactivation\u201d, is  the  most common method of interaction. And thankfully, it is also one of the simplest to handle.",
            "title": "Player Right Click"
        },
        {
            "location": "/blocks/interaction/#onblockactivated",
            "text": "This is the method that controls right click behavior, and it is a rather complicated one. Here is its full signature:  public boolean onBlockActivated(World worldIn,\n                                BlockPos pos,\n                                IBlockState state,\n                                EntityPlayer playerIn,\n                                EnumHand hand,\n                                @Nullable ItemStack heldItem,\n                                EnumFacing side,\n                                float hitX,\n                                float hitY,\n                                float hitZ)  There\u2019s quite a bit to discuss here.",
            "title": "onBlockActivated"
        },
        {
            "location": "/blocks/interaction/#parameters",
            "text": "The first few parameters are obvious, they are the current world, position, and state of the block. Next is the player that is activating the block, and the hand with which they are activating.  The next parameter,  heldItem , is the  ItemStack  which the player activated the block with. Note that this parameter is  @Nullable  meaning it can be passed as null (i.e. no item was in the hand).   Important  The ItemStack passed to this method is the one you should use for checking what was in the player\u2019s hand. Grabbing the currently held stack from the player is unreliable as it may have changed since activation.   The last four parameters are all related.  side  is obviously the side which was activated, however  hitX ,  hitY , and  hitZ  are a bit less obvious. These are the coordinates of the activation on the block\u2019s bounds. They are on the range 0 to 1, and represent where exactly \u201con\u201d the block the player clicked.",
            "title": "Parameters"
        },
        {
            "location": "/blocks/interaction/#return-value",
            "text": "What is this magic boolean which must be returned? Simply put this, is whether or not the method \u201cdid\u201d something. Return true if some action was performed, this will prevent further things from happening, such as item activation.   Important  Returning  false  from this method on the client will prevent it being called on the server. It is common practice to just check  worldIn.isRemote  and return  true , and otherwise go on to normal activation logic. Vanilla has many examples of this, such as the chest.",
            "title": "Return Value"
        },
        {
            "location": "/blocks/interaction/#uses",
            "text": "The uses for activation are literally endless. However, there are some common ones which deserve their own section.",
            "title": "Uses"
        },
        {
            "location": "/blocks/interaction/#guis",
            "text": "One of the most common things to do on block activation is opening a GUI. Many blocks in vanilla behave this way, such as chests, hoppers, furnaces, and many more. More about GUIs can be found on  their page .",
            "title": "GUIs"
        },
        {
            "location": "/blocks/interaction/#activation",
            "text": "Another common use for activation is, well, activation. This can be something like \u201cturning on\u201d a block, or triggering it to perform some action. For instance, a block could light up when activated. A vanilla example would be buttons or levers.   Important  onBlockActivated  is called on both the client and the server, so be sure to keep the  sidedness  of your code in mind. Many things, like opening GUIs and modifying the world, should only be done on the server-side.",
            "title": "Activation"
        },
        {
            "location": "/blocks/interaction/#player-breakdestroy",
            "text": "Coming Soon",
            "title": "Player Break/Destroy"
        },
        {
            "location": "/blocks/interaction/#player-highlighting",
            "text": "Coming Soon",
            "title": "Player Highlighting"
        },
        {
            "location": "/blocks/interaction/#entity-collision",
            "text": "Coming Soon",
            "title": "Entity Collision"
        },
        {
            "location": "/blockstates/states/",
            "text": "Block States\n\n\nPlease read \nall\n of this guide before starting to code. Your understanding will be more comprehensive and correct than if you just picked parts out.\nThis guide is designed for an entry level introduction to Block States. If you know what Extended States are, you\u2019ll notice some simplifying assumptions I\u2019ve made below. They are intentional and are meant to avoid overloading beginners with information they may not immediately need. If you don\u2019t know what they are, no need to fear, there will be another document for them eventually.\n\n\nMotivation\n\n\nIn Minecraft 1.8 and above, direct manipulation of blocks and metadata values have been abstracted away into what is known as blockstates.\nThe premise of the system is to remove the usage and manipulation of raw metadata numbers, which are nondescript and carry no meaning.\n\n\nFor example, consider this switch statement for some arbitrary block that can face a direction and be on either half of the block space:\n\n\nswitch(meta) {\n  case 0: // it's south and on the lower half of the block\n  case 1: // it's south on the upper side of the block\n  case 2: // it's north and on the lower half of the block\n  case 3: // it's north and on the upper half of the block\n  ... etc.\n}\n\n\n\n\nThe numbers themselves carry no meaning whatsoever! If the comments weren\u2019t there we would have no idea what the meaning of each number is.\n\n\nA New Way of Thinking\n\n\nHow about, instead of having to munge around with numbers everywhere, we instead use some system that abstracts out the details of saving from the semantics of the block itself?\nThis is where \nIProperty<?>\n comes in. Each Block has a set of zero or more of these objects, that describe, unsurprisingly, \nproperties\n that the block have. Examples of this include color (\nIProperty<EnumDyeColor>\n), facing (\nIProperty<EnumFacing>\n), integer and boolean values, etc. Each property can have a \nvalue\n of the type parametrized by \nIProperty\n. For example, for the respective example properties, we can have values \nEnumDyeColor.WHITE\n, \nEnumFacing.EAST\n, \n1\n, or \nfalse\n.\n\n\nThen, following from this, we see that every unique triple (Block, set of properties, set of values for those properties) is a suitable abstracted replacement for Block and metadata. Now, instead of \u201cminecraft:stone_button meta 9\u201d we have \u201cminecraft:stone_button[facing=east,powered=true]\u201d. Guess which is more meaningful?\n\n\nWe have a very special name for these triples - they\u2019re called \nIBlockState\n\u2018s.\n\n\nImbuing your Blocks with these Magical Properties\n\n\nNow that I\u2019ve successfully convinced you that properties and values are superior to arbitrary numbers, let\u2019s move on to the actual how-to-do part.\n\n\nIn your Block class, create static final \nIProperty<>\n objects for every property that your Block has. Vanilla provides us several convenience implementations:\n\n\n\n\nPropertyInteger\n: Implements \nIProperty<Integer>\n. Created by calling PropertyInteger.create(\u201c\n\u201c, \n, \n);\n\n\nPropertyBool\n: Implements \nIProperty<Boolean>\n. Created by calling PropertyBool.create(\u201c\n\u201c);\n\n\nPropertyEnum<E extends Enum<E>>\n: Implements \nIProperty<E>\n, Defines a property that can take on the values of an Enum class. Created by calling PropertyEnum.create(\u201cname\u201d, \n);\n\n\nYou can also use only a subset of the Enum values (for example, you can use only 4 of the 16 \nEnumDyeColor\n\u2018s. Take a look at the other overloads of \nPropertyEnum.create\n)\n\n\n\n\n\n\nPropertyDirection\n: This is a convenience implementation of \nPropertyEnum<EnumFacing>\n\n\nSeveral convenience predicates are also provided. For example, to get a property that represents the cardinal directions, you would call \nPropertyDirection.create(\"<name>\", EnumFacing.Plane.HORIZONTAL)\n. Or to get the X directions, \nPropertyDirection.create(\"<name>\", EnumFacing.Axis.X)\n\n\n\n\n\n\n\n\nNote that you are free to make your own \nIProperty<>\n implementations, but the means to do that are not covered in this article.\nIn addition, note that you can share the same \nIProperty\n object between different blocks if you wish. Vanilla generally has separate ones for every single block, but it is merely personal preference.\n\n\n\n\nNote\n\n\nIf your mod has an API or is meant to be interacted with from other mods, it is \nvery highly\n recommended that you instead place your \nIProperty\n\u2018s (and any classes used as values) in your API. That way, people can use properties and values to set your blocks in the world instead of having to suffer with arbitrary numbers like you used to.\n\n\n\n\nAfter you\u2019ve created your \nIProperty<>\n objects, override \ncreateBlockState\n in your Block class. In that method, simply write \nreturn new BlockState()\n. Pass the \nBlockState\n constructor first your Block, \nthis\n, then follow it with every \nIProperty\n you want to declare. Note that in 1.9 and above, the \nBlockState\n class has been renamed to \nBlockStateContainer\n, more in line with what this class actually does.\n\n\nThe object you just created is a pretty magical one - it manages the generation of all the triples above. That is, it generates all possible combinations of every value for each property (for math-oriented people, it takes the set of possible values of each property and computes the cartesian product of those sets). Thus, it generates every unique (Block, properties, values) possible - every \nIBlockState\n possible for the given properties.\n\n\nIf you do not set one of these \nIBlockState\n\u2018s to act as the \u201cdefault\u201d state for your Block, then one is chosen for you. You probably don\u2019t want this (it will cause weird things to happen most of the time), so at the end of your Block\u2019s constructor call \nsetDefaultState()\n, passing in the \nIBlockState\n you want to be the default. Get the one that was chosen for you using \nthis.blockState.getBaseState()\n then set a value for \nevery\n property using \nwithProperty\n\n\nBecause \nIBlockState\n\u2018s are immutable and pregenerated, calling \nIBlockState.withProperty(<PROPERTY>, <NEW_VALUE>)\n will simply go to the \nBlockState\n/\nBlockStateContainer\n and request the IBlockState with the set of values you want, instead of constructing a new \nIBlockState\n.\n\n\nIt follows very easily from this that since basic \nIBlockState\n\u2018s are generated into a fixed set at startup, you are able and encouraged to use reference comparison (==) to check if they are equal!\n\n\nUsing \nIBlockState\n\u2018s\n\n\nIBlockState\n, as we know now, is a powerful object. You can get the value of a property by calling \ngetValue(<PROPERTY>)\n, passing it the \nIProperty<>\n you want to test.\nIf you want to get an IBlockState with a different set of values, simply call \nwithProperty(<PROPERTY>, <NEW_VALUE>)\n as mentioned above. This will return another of the pregenerated \nIBlockState\n\u2018s with the values you requested.\n\n\nYou can get and put \nIBlockState\n\u2018s in the world using \nsetBlockState()\n and \ngetBlockState()\n.\n\n\nIllusion Breaker\n\n\nSadly, abstractions are lies at their core. We still have the responsibility of translating every \nIBlockState\n back into a number between 0 and 15 inclusive that will be stored in the world and vice versa for loading.\n\n\nIf you declare any \nIProperty\n\u2018s, you \nmust\n override \ngetMetaFromState\n and \ngetStateFromMeta\n\n\nHere you will read the values of your properties and return an appropriate integer between 0 and 15, or the other way around; the reader is left to check examples from vanilla blocks by themselves.\n\n\n\n\nWarning\n\n\nYour getMetaFromState and getStateFromMeta methods \nmust\n be one to one! In other words, the same set of properties and values must map to the same meta value and back. Failing to do this, unfortunately, \nwon\u2019t\n cause a crash. It\u2019ll just cause everything to behave extremely weirdly.\n\n\n\n\n\u201cActual\u201d States\n\n\nSome sharper minds might know that fences don\u2019t save any of their connections to meta, yet they still have properties and values in the F3 menu! What is this blasphemy?!\n\n\nBlocks can declare properties that are not saved to metadata. These are usually used for rendering purposes, but could possibly have other useful applications.\nYou still declare them in \ncreateBlockState\n and set their value in \nsetDefaultState\n. However, these properties you do \nnot\n touch \nat all\n in \ngetMetaFromState\n and \ngetStateFromMeta\n.\n\n\nInstead, override \ngetActualState\n in your Block class. Here you will receive the \nIBlockState\n corresponding with the metadata in the world, and you return another \nIBlockState\n with missing information such as fence connections, redstone connections , etc. filled in using \nwithProperty\n. You can also use this to read Tile Entity data for a value (with appropriate safety checks of course!).\n\n\n\n\nWarning\n\n\nWhen you read tile entity data in \ngetActualState\n you must perform additional safety checks. By default, \ngetTileEntity\n attempts to create the tile entity if it is not already present. However, \ngetActualState\n and \ngetExtendedState\n can and will be called from different threads, which can cause the world\u2019s tile entity list to throw a \nConcurrentModificationException\n if it tries to create a missing tile entity. Therefore, you must check if the \nIBlockAccess\n argument is a \nChunkCache\n (the object passed to alternate threads), and if so, cast and use the non-writing variant of \ngetTileEntity\n. An example of this safety check can be found in \nBlockFlowerPot.getActualState()\n.\n\n\n\n\n\n\nNote\n\n\nQuerying \nworld.getBlockState()\n will give you the \nIBlockState\n representing only the metadata. Thus the returned \nIBlockState\n will not have data from \ngetActualState\n filled in. If that matters to your code, make sure you call \ngetActualState\n!\n\n\n\n\nFurther Reading\n\n\n\n\nRendering in 1.8+: TODO\n\n\nExtended States: TODO",
            "title": "Intro to Blockstates"
        },
        {
            "location": "/blockstates/states/#block-states",
            "text": "Please read  all  of this guide before starting to code. Your understanding will be more comprehensive and correct than if you just picked parts out.\nThis guide is designed for an entry level introduction to Block States. If you know what Extended States are, you\u2019ll notice some simplifying assumptions I\u2019ve made below. They are intentional and are meant to avoid overloading beginners with information they may not immediately need. If you don\u2019t know what they are, no need to fear, there will be another document for them eventually.",
            "title": "Block States"
        },
        {
            "location": "/blockstates/states/#motivation",
            "text": "In Minecraft 1.8 and above, direct manipulation of blocks and metadata values have been abstracted away into what is known as blockstates.\nThe premise of the system is to remove the usage and manipulation of raw metadata numbers, which are nondescript and carry no meaning.  For example, consider this switch statement for some arbitrary block that can face a direction and be on either half of the block space:  switch(meta) {\n  case 0: // it's south and on the lower half of the block\n  case 1: // it's south on the upper side of the block\n  case 2: // it's north and on the lower half of the block\n  case 3: // it's north and on the upper half of the block\n  ... etc.\n}  The numbers themselves carry no meaning whatsoever! If the comments weren\u2019t there we would have no idea what the meaning of each number is.",
            "title": "Motivation"
        },
        {
            "location": "/blockstates/states/#a-new-way-of-thinking",
            "text": "How about, instead of having to munge around with numbers everywhere, we instead use some system that abstracts out the details of saving from the semantics of the block itself?\nThis is where  IProperty<?>  comes in. Each Block has a set of zero or more of these objects, that describe, unsurprisingly,  properties  that the block have. Examples of this include color ( IProperty<EnumDyeColor> ), facing ( IProperty<EnumFacing> ), integer and boolean values, etc. Each property can have a  value  of the type parametrized by  IProperty . For example, for the respective example properties, we can have values  EnumDyeColor.WHITE ,  EnumFacing.EAST ,  1 , or  false .  Then, following from this, we see that every unique triple (Block, set of properties, set of values for those properties) is a suitable abstracted replacement for Block and metadata. Now, instead of \u201cminecraft:stone_button meta 9\u201d we have \u201cminecraft:stone_button[facing=east,powered=true]\u201d. Guess which is more meaningful?  We have a very special name for these triples - they\u2019re called  IBlockState \u2018s.",
            "title": "A New Way of Thinking"
        },
        {
            "location": "/blockstates/states/#imbuing-your-blocks-with-these-magical-properties",
            "text": "Now that I\u2019ve successfully convinced you that properties and values are superior to arbitrary numbers, let\u2019s move on to the actual how-to-do part.  In your Block class, create static final  IProperty<>  objects for every property that your Block has. Vanilla provides us several convenience implementations:   PropertyInteger : Implements  IProperty<Integer> . Created by calling PropertyInteger.create(\u201c \u201c,  ,  );  PropertyBool : Implements  IProperty<Boolean> . Created by calling PropertyBool.create(\u201c \u201c);  PropertyEnum<E extends Enum<E>> : Implements  IProperty<E> , Defines a property that can take on the values of an Enum class. Created by calling PropertyEnum.create(\u201cname\u201d,  );  You can also use only a subset of the Enum values (for example, you can use only 4 of the 16  EnumDyeColor \u2018s. Take a look at the other overloads of  PropertyEnum.create )    PropertyDirection : This is a convenience implementation of  PropertyEnum<EnumFacing>  Several convenience predicates are also provided. For example, to get a property that represents the cardinal directions, you would call  PropertyDirection.create(\"<name>\", EnumFacing.Plane.HORIZONTAL) . Or to get the X directions,  PropertyDirection.create(\"<name>\", EnumFacing.Axis.X)     Note that you are free to make your own  IProperty<>  implementations, but the means to do that are not covered in this article.\nIn addition, note that you can share the same  IProperty  object between different blocks if you wish. Vanilla generally has separate ones for every single block, but it is merely personal preference.   Note  If your mod has an API or is meant to be interacted with from other mods, it is  very highly  recommended that you instead place your  IProperty \u2018s (and any classes used as values) in your API. That way, people can use properties and values to set your blocks in the world instead of having to suffer with arbitrary numbers like you used to.   After you\u2019ve created your  IProperty<>  objects, override  createBlockState  in your Block class. In that method, simply write  return new BlockState() . Pass the  BlockState  constructor first your Block,  this , then follow it with every  IProperty  you want to declare. Note that in 1.9 and above, the  BlockState  class has been renamed to  BlockStateContainer , more in line with what this class actually does.  The object you just created is a pretty magical one - it manages the generation of all the triples above. That is, it generates all possible combinations of every value for each property (for math-oriented people, it takes the set of possible values of each property and computes the cartesian product of those sets). Thus, it generates every unique (Block, properties, values) possible - every  IBlockState  possible for the given properties.  If you do not set one of these  IBlockState \u2018s to act as the \u201cdefault\u201d state for your Block, then one is chosen for you. You probably don\u2019t want this (it will cause weird things to happen most of the time), so at the end of your Block\u2019s constructor call  setDefaultState() , passing in the  IBlockState  you want to be the default. Get the one that was chosen for you using  this.blockState.getBaseState()  then set a value for  every  property using  withProperty  Because  IBlockState \u2018s are immutable and pregenerated, calling  IBlockState.withProperty(<PROPERTY>, <NEW_VALUE>)  will simply go to the  BlockState / BlockStateContainer  and request the IBlockState with the set of values you want, instead of constructing a new  IBlockState .  It follows very easily from this that since basic  IBlockState \u2018s are generated into a fixed set at startup, you are able and encouraged to use reference comparison (==) to check if they are equal!",
            "title": "Imbuing your Blocks with these Magical Properties"
        },
        {
            "location": "/blockstates/states/#using-iblockstates",
            "text": "IBlockState , as we know now, is a powerful object. You can get the value of a property by calling  getValue(<PROPERTY>) , passing it the  IProperty<>  you want to test.\nIf you want to get an IBlockState with a different set of values, simply call  withProperty(<PROPERTY>, <NEW_VALUE>)  as mentioned above. This will return another of the pregenerated  IBlockState \u2018s with the values you requested.  You can get and put  IBlockState \u2018s in the world using  setBlockState()  and  getBlockState() .",
            "title": "Using IBlockState's"
        },
        {
            "location": "/blockstates/states/#illusion-breaker",
            "text": "Sadly, abstractions are lies at their core. We still have the responsibility of translating every  IBlockState  back into a number between 0 and 15 inclusive that will be stored in the world and vice versa for loading.  If you declare any  IProperty \u2018s, you  must  override  getMetaFromState  and  getStateFromMeta  Here you will read the values of your properties and return an appropriate integer between 0 and 15, or the other way around; the reader is left to check examples from vanilla blocks by themselves.   Warning  Your getMetaFromState and getStateFromMeta methods  must  be one to one! In other words, the same set of properties and values must map to the same meta value and back. Failing to do this, unfortunately,  won\u2019t  cause a crash. It\u2019ll just cause everything to behave extremely weirdly.",
            "title": "Illusion Breaker"
        },
        {
            "location": "/blockstates/states/#actual-states",
            "text": "Some sharper minds might know that fences don\u2019t save any of their connections to meta, yet they still have properties and values in the F3 menu! What is this blasphemy?!  Blocks can declare properties that are not saved to metadata. These are usually used for rendering purposes, but could possibly have other useful applications.\nYou still declare them in  createBlockState  and set their value in  setDefaultState . However, these properties you do  not  touch  at all  in  getMetaFromState  and  getStateFromMeta .  Instead, override  getActualState  in your Block class. Here you will receive the  IBlockState  corresponding with the metadata in the world, and you return another  IBlockState  with missing information such as fence connections, redstone connections , etc. filled in using  withProperty . You can also use this to read Tile Entity data for a value (with appropriate safety checks of course!).   Warning  When you read tile entity data in  getActualState  you must perform additional safety checks. By default,  getTileEntity  attempts to create the tile entity if it is not already present. However,  getActualState  and  getExtendedState  can and will be called from different threads, which can cause the world\u2019s tile entity list to throw a  ConcurrentModificationException  if it tries to create a missing tile entity. Therefore, you must check if the  IBlockAccess  argument is a  ChunkCache  (the object passed to alternate threads), and if so, cast and use the non-writing variant of  getTileEntity . An example of this safety check can be found in  BlockFlowerPot.getActualState() .    Note  Querying  world.getBlockState()  will give you the  IBlockState  representing only the metadata. Thus the returned  IBlockState  will not have data from  getActualState  filled in. If that matters to your code, make sure you call  getActualState !",
            "title": "\"Actual\" States"
        },
        {
            "location": "/blockstates/states/#further-reading",
            "text": "Rendering in 1.8+: TODO  Extended States: TODO",
            "title": "Further Reading"
        },
        {
            "location": "/blockstates/introduction/",
            "text": "Introduction to blockstate JSONs\n\n\nBlockstate JSONs tell the game which model it should use depending on the values of the block\u2019s \nblockstate properties\n.\nA simple block with no properties only has a \u201c\nnormal\n\u201d blockstate which is its default.\nA more complex block that can be displayed in different ways has so called \nvariants\n.\n\n\nAs an example, let\u2019s take a look at the vanilla \noak_log.json\n:\n\n\n{\n    \"variants\": {\n        \"axis=y\":    { \"model\": \"oak_log\" },\n        \"axis=z\":     { \"model\": \"oak_log_side\" },\n        \"axis=x\":     { \"model\": \"oak_log_side\", \"y\": 90 },\n        \"axis=none\":   { \"model\": \"oak_bark\" }\n    }\n}\n\n\n\n\nAs you can see there is no normal state, only different variants depending on the value of \u201caxis\u201d. Depending on which axis the log is aligned it will use either a model of the upright log, a model of the sideways log (rotated by 90\u00b0 or not) or, should the block not have any axis set, it\u2019ll display the bark model which has the bark on all 6 sides.\n\n\nThe log only has one property: axis. A blockstate always has to be defined for all of its properties. This can quickly lead to a combinatorial explosion of variants. Let\u2019s look at one variant of the vanilla fence:\n\n\n\"east=false,north=false,south=false,west=false\": { \"model\": \"oak_fence_post\" }\n\n\n\n\nIt should also be noted that in vanilla blockstate JSONs, the property names must be in alphabetical order, keeping in mind that resource and property names must be lower case. This includes the blockstate variants (\n\"east=false\"\n) themselves.\n\n\nAnd that is only one variant of 16. This can quickly lead to very big and verbose blockstate files, and is one of the main problems in Minecraft 1.8. Minecraft 1.9 will introduce a system that allows to get this under control. \nForge\u2019s Blockstate Json\n allows you to do so in 1.8.",
            "title": "Intro to Blockstate JSONs"
        },
        {
            "location": "/blockstates/introduction/#introduction-to-blockstate-jsons",
            "text": "Blockstate JSONs tell the game which model it should use depending on the values of the block\u2019s  blockstate properties .\nA simple block with no properties only has a \u201c normal \u201d blockstate which is its default.\nA more complex block that can be displayed in different ways has so called  variants .  As an example, let\u2019s take a look at the vanilla  oak_log.json :  {\n    \"variants\": {\n        \"axis=y\":    { \"model\": \"oak_log\" },\n        \"axis=z\":     { \"model\": \"oak_log_side\" },\n        \"axis=x\":     { \"model\": \"oak_log_side\", \"y\": 90 },\n        \"axis=none\":   { \"model\": \"oak_bark\" }\n    }\n}  As you can see there is no normal state, only different variants depending on the value of \u201caxis\u201d. Depending on which axis the log is aligned it will use either a model of the upright log, a model of the sideways log (rotated by 90\u00b0 or not) or, should the block not have any axis set, it\u2019ll display the bark model which has the bark on all 6 sides.  The log only has one property: axis. A blockstate always has to be defined for all of its properties. This can quickly lead to a combinatorial explosion of variants. Let\u2019s look at one variant of the vanilla fence:  \"east=false,north=false,south=false,west=false\": { \"model\": \"oak_fence_post\" }  It should also be noted that in vanilla blockstate JSONs, the property names must be in alphabetical order, keeping in mind that resource and property names must be lower case. This includes the blockstate variants ( \"east=false\" ) themselves.  And that is only one variant of 16. This can quickly lead to very big and verbose blockstate files, and is one of the main problems in Minecraft 1.8. Minecraft 1.9 will introduce a system that allows to get this under control.  Forge\u2019s Blockstate Json  allows you to do so in 1.8.",
            "title": "Introduction to blockstate JSONs"
        },
        {
            "location": "/blockstates/forgeBlockstates/",
            "text": "Forge\u2019s Blockstates\n\n\nForge has its own blockstate json format to accommodate for modders needs. It introduces submodels, which allows you to build the final blockstate from different parts. You can build a models \nnormal\n blockstate from multiple parts as well as create a complex variant depending on the blocks properties.\n\n\n\n\nAttention\n\n\nNote that all models and textures referenced are from vanilla minecraft. For your own mod, you have to use the full location! For example: \n\"mymod:blocks/blockTexture\"\n.\n\n\nYou don\u2019t have to use Forge\u2019s blockstate format at all, you can also use the vanilla format!\n\n\n\n\nGeneral Structure of the Format\n\n\n{\n    \"forge_marker\": 1,\n    \"defaults\": {\n        \"textures\": {\n            \"all\": \"blocks/dirt\"\n        },\n        \"model\": \"cube_all\",\n        \"uvlock\": true\n    },\n    \"variants\": {\n        \"normal\": [{\n\n        }]\n    }\n}\n\n\n\n\nThis json declares a simple blockstate that has dirt on each side. Let\u2019s go through it step by step.\n\n\n    \"forge_marker\": 1,\n\n\n\n\nThis tells the game that the blockstate json is the one from Forge, not from vanilla Minecraft.\nThe 1 is the version of the format, which ensures that old blockstate JSONs can be supported should the format ever change. Currently there is only this one.\n\n\n    \"defaults\": {\n        \"textures\": {\n            \"all\": \"blocks/dirt\"\n        },\n        \"model\": \"cube_all\",\n        \"uvlock\": true\n    }\n\n\n\n\nThe defaults section contains the default values for all variants. They can be overwritten by the variants. The defaults section is \noptional\n! You do not need to define defaults, the block can be omitted altogether.\n\n\n    \"variants\": {\n        \"normal\": [{\n\n        }]\n    }\n\n\n\n\nThis defines all variants for the block. The simple dirt block only has its default, the \nnormal\n variant. It does not contain any additional information in this case. Everything that is defined in defaults could also be defined here.\nFor example:\n\n\n    \"normal\": [{\n        \"textures\": {\n            \"side\": \"blocks/cobblestone\",\n            \"end\": \"blocks/dirt\"\n        },\n        \"model\": \"cube_column\"\n    }]\n\n\n\n\nThis normal variant would use the \ncube_column\n model with cobblestone on the sides and dirt on top and bottom.\n\n\nSub-Models\n\n\nTo show the use of submodels we will create a model that has different variants. Each variant will use submodels to create a different model.\nThe model will be a pressure plate, and depending on its state it will have parts added to it.\n\n\n{\n    \"forge_marker\": 1,\n    \"defaults\": {\n        \"textures\": {\n            \"texture\": \"blocks/planks_oak\",\n            \"wall\": \"blocks/planks_oak\"\n        },\n        \"model\": \"pressure_plate_up\",\n        \"uvlock\": true\n    },\n    \"variants\": {\n        // mossy is a boolean property.\n        \"mossy\": {\n            \"true\": {\n                // if true it changes the pressure plate from oak planks to mossy cobble\n                \"textures\": {\n                    \"texture\": \"blocks/cobblestone_mossy\"\n                }\n            },\n            \"false\": {\n                // change nothing. The entry has to be here to be generated for internal usage by minecraft\n            }\n        },\n        // pillarcount is a property that determines how many pillar submodels we have. Ranges from 0 to 2\n        \"pillarcount\": {\n            0: {\n                // no pillar. Remember, has to be there.\n            },\n            1: {\n                // if it is true, it will add the wall model and combine it with the pressure plate\n                \"submodel\": \"wall_n\"\n            },\n            2: {\n                \"textures\": {\n                    \"wall\": \"blocks/cobblestone\"\n                },\n                \"submodel\": {\n                    \"pillar1\": { \"model\": \"wall_n\" },\n                    \"pillar2\": { \"model\": \"wall_n\", \"y\": 90 }\n                }\n            }\n        }\n    }\n}\n\n\n\n\nThe comments already explain the details on the separate parts, but here\u2019s how it works overall: The block definition in code has two Properties. One boolean property named \u201cmossy\u201d and one integer property named \u201cpillarCount\u201d. Notice here that the string used in the json is \nlowercase\n, however. It has to be lowercase or it wont be found.\n\n\nInstead of defining \u201cthis combination of properties gives model X\u201d we say \u201c\nthis\n value for this property has \nthat\n impact on the model\u201d. In this example it\u2019s quite straight forward:\n\n\n\n\nIf mossy is true, the pressure plate uses the mossy cobblestone texture\n\n\nIf pillarCount is 1 it will add one wall with connection facing north. The default texture for the wall is oak-planks.\n\n\nIf pillarCount is 2 it will add two walls, both facing north. However the second wall will be rotated by 90 degree. This showcases that you do not need separate model with Forge\u2019s system. You only need once and rotate it around the Y axis. Additionally the texture of the walls is changed to cobblestone.\n\n\nIf pillarCount is 0 no walls will be added.\n\n\n\n\nAnd here is the result of our work:",
            "title": "Forge Blockstate JSON"
        },
        {
            "location": "/blockstates/forgeBlockstates/#forges-blockstates",
            "text": "Forge has its own blockstate json format to accommodate for modders needs. It introduces submodels, which allows you to build the final blockstate from different parts. You can build a models  normal  blockstate from multiple parts as well as create a complex variant depending on the blocks properties.   Attention  Note that all models and textures referenced are from vanilla minecraft. For your own mod, you have to use the full location! For example:  \"mymod:blocks/blockTexture\" .  You don\u2019t have to use Forge\u2019s blockstate format at all, you can also use the vanilla format!",
            "title": "Forge's Blockstates"
        },
        {
            "location": "/blockstates/forgeBlockstates/#general-structure-of-the-format",
            "text": "{\n    \"forge_marker\": 1,\n    \"defaults\": {\n        \"textures\": {\n            \"all\": \"blocks/dirt\"\n        },\n        \"model\": \"cube_all\",\n        \"uvlock\": true\n    },\n    \"variants\": {\n        \"normal\": [{\n\n        }]\n    }\n}  This json declares a simple blockstate that has dirt on each side. Let\u2019s go through it step by step.      \"forge_marker\": 1,  This tells the game that the blockstate json is the one from Forge, not from vanilla Minecraft.\nThe 1 is the version of the format, which ensures that old blockstate JSONs can be supported should the format ever change. Currently there is only this one.      \"defaults\": {\n        \"textures\": {\n            \"all\": \"blocks/dirt\"\n        },\n        \"model\": \"cube_all\",\n        \"uvlock\": true\n    }  The defaults section contains the default values for all variants. They can be overwritten by the variants. The defaults section is  optional ! You do not need to define defaults, the block can be omitted altogether.      \"variants\": {\n        \"normal\": [{\n\n        }]\n    }  This defines all variants for the block. The simple dirt block only has its default, the  normal  variant. It does not contain any additional information in this case. Everything that is defined in defaults could also be defined here.\nFor example:      \"normal\": [{\n        \"textures\": {\n            \"side\": \"blocks/cobblestone\",\n            \"end\": \"blocks/dirt\"\n        },\n        \"model\": \"cube_column\"\n    }]  This normal variant would use the  cube_column  model with cobblestone on the sides and dirt on top and bottom.",
            "title": "General Structure of the Format"
        },
        {
            "location": "/blockstates/forgeBlockstates/#sub-models",
            "text": "To show the use of submodels we will create a model that has different variants. Each variant will use submodels to create a different model.\nThe model will be a pressure plate, and depending on its state it will have parts added to it.  {\n    \"forge_marker\": 1,\n    \"defaults\": {\n        \"textures\": {\n            \"texture\": \"blocks/planks_oak\",\n            \"wall\": \"blocks/planks_oak\"\n        },\n        \"model\": \"pressure_plate_up\",\n        \"uvlock\": true\n    },\n    \"variants\": {\n        // mossy is a boolean property.\n        \"mossy\": {\n            \"true\": {\n                // if true it changes the pressure plate from oak planks to mossy cobble\n                \"textures\": {\n                    \"texture\": \"blocks/cobblestone_mossy\"\n                }\n            },\n            \"false\": {\n                // change nothing. The entry has to be here to be generated for internal usage by minecraft\n            }\n        },\n        // pillarcount is a property that determines how many pillar submodels we have. Ranges from 0 to 2\n        \"pillarcount\": {\n            0: {\n                // no pillar. Remember, has to be there.\n            },\n            1: {\n                // if it is true, it will add the wall model and combine it with the pressure plate\n                \"submodel\": \"wall_n\"\n            },\n            2: {\n                \"textures\": {\n                    \"wall\": \"blocks/cobblestone\"\n                },\n                \"submodel\": {\n                    \"pillar1\": { \"model\": \"wall_n\" },\n                    \"pillar2\": { \"model\": \"wall_n\", \"y\": 90 }\n                }\n            }\n        }\n    }\n}  The comments already explain the details on the separate parts, but here\u2019s how it works overall: The block definition in code has two Properties. One boolean property named \u201cmossy\u201d and one integer property named \u201cpillarCount\u201d. Notice here that the string used in the json is  lowercase , however. It has to be lowercase or it wont be found.  Instead of defining \u201cthis combination of properties gives model X\u201d we say \u201c this  value for this property has  that  impact on the model\u201d. In this example it\u2019s quite straight forward:   If mossy is true, the pressure plate uses the mossy cobblestone texture  If pillarCount is 1 it will add one wall with connection facing north. The default texture for the wall is oak-planks.  If pillarCount is 2 it will add two walls, both facing north. However the second wall will be rotated by 90 degree. This showcases that you do not need separate model with Forge\u2019s system. You only need once and rotate it around the Y axis. Additionally the texture of the walls is changed to cobblestone.  If pillarCount is 0 no walls will be added.   And here is the result of our work:",
            "title": "Sub-Models"
        },
        {
            "location": "/items/items/",
            "text": "Items\n\n\nAlong with blocks, items are a key component of most mods. While blocks make up the world around you, items are what let you change it.\n\n\nCreating an Item\n\n\nBasic Items\n\n\nBasic items that need no special functionality (think sticks or sugar) don\u2019t need custom classes. You can simply instantiate \nItem\n and call its various setters to set some simple properties.\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsetCreativeTab\n\n\nSets which creative tab this item is under. Must be called if this item is meant to be shown on the creative menu. Vanilla tabs can be found in the class \nCreativeTabs\n.\n\n\n\n\n\n\nsetMaxDamage\n\n\nSets the maximum damage value for this item. If it\u2019s over \n0\n, 2 item properties \u201cdamaged\u201d and \u201cdamage\u201d are added.\n\n\n\n\n\n\nsetMaxStackSize\n\n\nSets the maximum stack size.\n\n\n\n\n\n\nsetNoRepair\n\n\nMakes this item impossible to repair, even if it is damageable.\n\n\n\n\n\n\nsetUnlocalizedName\n\n\nSets this item\u2019s unlocalized name, with \u201citem.\u201d prepended.\n\n\n\n\n\n\nsetHarvestLevel\n\n\nAdds or removes a pair of harvest class (\n\"shovel\"\n, \n\"axe\"\n) and harvest level. This method is not chainable.\n\n\n\n\n\n\n\n\nThe above methods are chainable, unless otherwise stated, meaning they \nreturn this\n to facilitate calling them in series.\n\n\nAdvanced Items\n\n\nSetting the properties of an item as above only works for simple items. If you want more complicated items, you should subclass Item and override its methods.\n\n\nRegistering an Item\n\n\nItems must be \nregistered\n to function.",
            "title": "Home"
        },
        {
            "location": "/items/items/#items",
            "text": "Along with blocks, items are a key component of most mods. While blocks make up the world around you, items are what let you change it.",
            "title": "Items"
        },
        {
            "location": "/items/items/#creating-an-item",
            "text": "",
            "title": "Creating an Item"
        },
        {
            "location": "/items/items/#basic-items",
            "text": "Basic items that need no special functionality (think sticks or sugar) don\u2019t need custom classes. You can simply instantiate  Item  and call its various setters to set some simple properties.     Method  Description      setCreativeTab  Sets which creative tab this item is under. Must be called if this item is meant to be shown on the creative menu. Vanilla tabs can be found in the class  CreativeTabs .    setMaxDamage  Sets the maximum damage value for this item. If it\u2019s over  0 , 2 item properties \u201cdamaged\u201d and \u201cdamage\u201d are added.    setMaxStackSize  Sets the maximum stack size.    setNoRepair  Makes this item impossible to repair, even if it is damageable.    setUnlocalizedName  Sets this item\u2019s unlocalized name, with \u201citem.\u201d prepended.    setHarvestLevel  Adds or removes a pair of harvest class ( \"shovel\" ,  \"axe\" ) and harvest level. This method is not chainable.     The above methods are chainable, unless otherwise stated, meaning they  return this  to facilitate calling them in series.",
            "title": "Basic Items"
        },
        {
            "location": "/items/items/#advanced-items",
            "text": "Setting the properties of an item as above only works for simple items. If you want more complicated items, you should subclass Item and override its methods.",
            "title": "Advanced Items"
        },
        {
            "location": "/items/items/#registering-an-item",
            "text": "Items must be  registered  to function.",
            "title": "Registering an Item"
        },
        {
            "location": "/events/intro/",
            "text": "Events\n\n\nForge uses an event bus that allows mods to intercept events from various vanilla and mod behaviors.\n\n\nExample: An event can be used to perform an action when a Vanilla stick is right clicked.\n\n\nThe main event bus used for most events is located at \nMinecraftForge.EVENT_BUS\n. There are also a few other buses used for specific types of events (like terrain generation) located in the same class.\n\n\nAn event handler is a class that contains one or more \npublic void\n member methods that are marked with the \n@SubscribeEvent\n annotation.\n\n\nCreating an Event Handler\n\n\npublic class MyForgeEventHandler {\n    @SubscribeEvent\n    public void pickupItem(EntityItemPickupEvent event) {\n        System.out.println(\"Item picked up!\");\n    }\n}\n\n\n\n\nThis event handler listens for the \nEntityItemPickupEvent\n, which is, as the name states, posted to the event bus whenever an \nEntity\n picks up an item.\n\n\nTo register this event handler, use \nMinecraftForge.EVENT_BUS.register()\n and pass it an instance of your event handler class.\n\n\n\n\nNote\n\n\nIn older forge versions, there were two separate event buses. One for forge, one for FML. This has long since been deprecated, so there is no need to use the FML event bus any longer.\n\n\n\n\nStatic Event Handlers\n\n\nAn event handler may also be static. The handling method is still annotated with \n@SubscribeEvent\n and the only difference from an instance handler is that it is also marked \nstatic\n. In order to register a static event handler, an instance of the class won\u2019t do, the \nClass\n itself has to be passed in. An example:\n\n\npublic class MyStaticForgeEventHandler {\n    @SubscribeEvent\n    public static void arrowNocked(ArrowNockEvent event) {\n        System.out.println(\"Arrow nocked!\");\n    }\n}\n\n\n\n\nwhich must be registered like this: \nMinecraftForge.EVENT_BUS.register(MyStaticForgeEventHandler.class)\n.\n\n\nAutomatically Registering Static Event Handlers\n\n\nA class may be annotated with the \n@Mod.EventBusSubscriber\n annotation. Such a class is automatically registered to \nMinecraftForge.EVENT_BUS\n when the \n@Mod\n class itself is constructed. This is essentially equivalent to adding \nMinecraftForge.EVENT_BUS.register(AnnotatedClass.class);\n at the end of the \n@Mod\n class\u2019s constructor.\n\n\n\n\nNote\n\n\nThis does not register an instance of the class; it registers the class itself (i.e. the event handling methods must be static).\n\n\n\n\nCanceling & Results\n\n\nIf an event can be canceled, it will be marked with the \n@Cancelable\n. Events can be canceled by calling \nsetCanceled\n on them with a boolean indicated if the event is canceled or not. If the event cannot be canceled, an \nIllegalArgumentException\n is thrown.\n\n\n\n\nImportant\n\n\nDifferent events may use results in different ways, refer to the event\u2019s JavaDoc before using the result.\n\n\n\n\nSome events have an \nEvent.Result\n, a result can be one of three things, \nDENY\n which stops the event, \nDEFAULT\n which uses the Vanilla behavior, and \nALLOW\n which forces the action to take place, regardless if it would have originally. The result of an event can be set by calling \nsetResult\n with an \nEvent.Result\n on the event. Not all events have results, an event with a result will be annotated with \n@HasResult\n.\n\n\nPriority\n\n\nEvent handler methods (marked with \n@SubscribeEvent\n) have a priority. You can set the priority of an event handler method by setting the \npriority\n value of the annotation. The priority can be any value of the \nEventPriority\n enum (\nHIGHEST\n, \nHIGH\n, \nNORMAL\n, \nLOW\n, and \nLOWEST\n). Event handlers with priority \nHIGHEST\n are executed first and from there in descending order until \nLOWEST\n events which are executed last.\n\n\nSub Events\n\n\nMany events have different variations of themselves, these can be different but all based around one common factor (e.g. \nPlayerEvent\n) or can be an event that has multiple phases (e.g. \nPotionBrewEvent\n). Take note that if you listen to the parent event class, you will receive calls to your method for \nall\n subclasses.",
            "title": "Basic Usage"
        },
        {
            "location": "/events/intro/#events",
            "text": "Forge uses an event bus that allows mods to intercept events from various vanilla and mod behaviors.  Example: An event can be used to perform an action when a Vanilla stick is right clicked.  The main event bus used for most events is located at  MinecraftForge.EVENT_BUS . There are also a few other buses used for specific types of events (like terrain generation) located in the same class.  An event handler is a class that contains one or more  public void  member methods that are marked with the  @SubscribeEvent  annotation.",
            "title": "Events"
        },
        {
            "location": "/events/intro/#creating-an-event-handler",
            "text": "public class MyForgeEventHandler {\n    @SubscribeEvent\n    public void pickupItem(EntityItemPickupEvent event) {\n        System.out.println(\"Item picked up!\");\n    }\n}  This event handler listens for the  EntityItemPickupEvent , which is, as the name states, posted to the event bus whenever an  Entity  picks up an item.  To register this event handler, use  MinecraftForge.EVENT_BUS.register()  and pass it an instance of your event handler class.   Note  In older forge versions, there were two separate event buses. One for forge, one for FML. This has long since been deprecated, so there is no need to use the FML event bus any longer.",
            "title": "Creating an Event Handler"
        },
        {
            "location": "/events/intro/#static-event-handlers",
            "text": "An event handler may also be static. The handling method is still annotated with  @SubscribeEvent  and the only difference from an instance handler is that it is also marked  static . In order to register a static event handler, an instance of the class won\u2019t do, the  Class  itself has to be passed in. An example:  public class MyStaticForgeEventHandler {\n    @SubscribeEvent\n    public static void arrowNocked(ArrowNockEvent event) {\n        System.out.println(\"Arrow nocked!\");\n    }\n}  which must be registered like this:  MinecraftForge.EVENT_BUS.register(MyStaticForgeEventHandler.class) .",
            "title": "Static Event Handlers"
        },
        {
            "location": "/events/intro/#automatically-registering-static-event-handlers",
            "text": "A class may be annotated with the  @Mod.EventBusSubscriber  annotation. Such a class is automatically registered to  MinecraftForge.EVENT_BUS  when the  @Mod  class itself is constructed. This is essentially equivalent to adding  MinecraftForge.EVENT_BUS.register(AnnotatedClass.class);  at the end of the  @Mod  class\u2019s constructor.   Note  This does not register an instance of the class; it registers the class itself (i.e. the event handling methods must be static).",
            "title": "Automatically Registering Static Event Handlers"
        },
        {
            "location": "/events/intro/#canceling-results",
            "text": "If an event can be canceled, it will be marked with the  @Cancelable . Events can be canceled by calling  setCanceled  on them with a boolean indicated if the event is canceled or not. If the event cannot be canceled, an  IllegalArgumentException  is thrown.   Important  Different events may use results in different ways, refer to the event\u2019s JavaDoc before using the result.   Some events have an  Event.Result , a result can be one of three things,  DENY  which stops the event,  DEFAULT  which uses the Vanilla behavior, and  ALLOW  which forces the action to take place, regardless if it would have originally. The result of an event can be set by calling  setResult  with an  Event.Result  on the event. Not all events have results, an event with a result will be annotated with  @HasResult .",
            "title": "Canceling &amp; Results"
        },
        {
            "location": "/events/intro/#priority",
            "text": "Event handler methods (marked with  @SubscribeEvent ) have a priority. You can set the priority of an event handler method by setting the  priority  value of the annotation. The priority can be any value of the  EventPriority  enum ( HIGHEST ,  HIGH ,  NORMAL ,  LOW , and  LOWEST ). Event handlers with priority  HIGHEST  are executed first and from there in descending order until  LOWEST  events which are executed last.",
            "title": "Priority"
        },
        {
            "location": "/events/intro/#sub-events",
            "text": "Many events have different variations of themselves, these can be different but all based around one common factor (e.g.  PlayerEvent ) or can be an event that has multiple phases (e.g.  PotionBrewEvent ). Take note that if you listen to the parent event class, you will receive calls to your method for  all  subclasses.",
            "title": "Sub Events"
        },
        {
            "location": "/networking/",
            "text": "Networking\n\n\nCommunication between servers and clients is the backbone of a successful mod implementation.\n\n\nRead an \noverview\n of why networking matters and the basic strategies in thinking about networking.\n\n\nThere are a variety of techniques provided by Forge to facilitate communication - mostly built on top of \nnetty\n.\n\n\nThe simplest, for a new mod, would be \nSimpleImpl\n, where most of the complexity of the netty system is\nabstracted away. It uses a message and handler style system.",
            "title": "Home"
        },
        {
            "location": "/networking/#networking",
            "text": "Communication between servers and clients is the backbone of a successful mod implementation.  Read an  overview  of why networking matters and the basic strategies in thinking about networking.  There are a variety of techniques provided by Forge to facilitate communication - mostly built on top of  netty .  The simplest, for a new mod, would be  SimpleImpl , where most of the complexity of the netty system is\nabstracted away. It uses a message and handler style system.",
            "title": "Networking"
        },
        {
            "location": "/networking/overview/",
            "text": "Overview\n\n\nThere are two primary goals in network communication:\n\n\n\n\nMaking sure the client view is \u201cin sync\u201d with the server view\n\n\nThe flower at coordinates X,Y,Z just grew\n\n\n\n\n\n\nGiving the client a way to tell the server that something has changed about the player\n\n\nthe player pressed a key\n\n\n\n\n\n\n\n\nThe most common way to accomplish these goals is to pass messages between the client and the server. These messages will\nusually be structured, containing data in a particular arrangement, for easy sending and receiving.",
            "title": "Overview"
        },
        {
            "location": "/networking/overview/#overview",
            "text": "There are two primary goals in network communication:   Making sure the client view is \u201cin sync\u201d with the server view  The flower at coordinates X,Y,Z just grew    Giving the client a way to tell the server that something has changed about the player  the player pressed a key     The most common way to accomplish these goals is to pass messages between the client and the server. These messages will\nusually be structured, containing data in a particular arrangement, for easy sending and receiving.",
            "title": "Overview"
        },
        {
            "location": "/networking/simpleimpl/",
            "text": "SimpleImpl\n\n\nSimpleImpl is the name given to the packet system that revolves around the \nSimpleNetworkWrapper\n class. Using this system is by far the easiest way to send custom data between clients and the server.\n\n\nGetting Started\n\n\nFirst you need to create your \nSimpleNetworkWrapper\n object. We recommend that you do this in a separate class, possibly something like \nModidPacketHandler\n. Create your \nSimpleNetworkWrapper\n as a static field in this class, like so:\n\n\npublic static final SimpleNetworkWrapper INSTANCE = NetworkRegistry.INSTANCE.newSimpleChannel(\"mymodid\");\n\n\n\n\nWhere \n\"mymodid\"\n is a short identifier for your packet channel, typically just your mod ID, unless that is unusually long.\n\n\nMaking Packets\n\n\nIMessage\n\n\nA packet is defined by using the \nIMessage\n interface. This interface defines 2 methods, \ntoBytes\n and \nfromBytes\n. These methods, respectively, write and read the data in your packet to and from a \nByteBuf\n object, which is an object used to hold a stream (array) of bytes which are sent through the network.\n\n\nFor an example, let\u2019s define a small packet that is designed to send a single int over the network:\n\n\npublic class MyMessage implements IMessage {\n  // A default constructor is always required\n  public MyMessage(){}\n\n  private int toSend;\n  public MyMessage(int toSend) {\n    this.toSend = toSend;\n  }\n\n  @Override public void toBytes(ByteBuf buf) {\n    // Writes the int into the buf\n    buf.writeInt(toSend);\n  }\n\n  @Override public void fromBytes(ByteBuf buf) {\n    // Reads the int back from the buf. Note that if you have multiple values, you must read in the same order you wrote.\n    toSend = buf.readInt();\n  }\n}\n\n\n\n\nIMessageHandler\n\n\nNow, how can we use this packet? Well, first we must have a class that can \nhandle\n this packet. This is created with the \nIMessageHandler\n interface. Say we wanted to use this integer we sent to give the player that many diamonds on the server. Let\u2019s make this handler:\n\n\n// The params of the IMessageHandler are <REQ, REPLY>\n// This means that the first param is the packet you are receiving, and the second is the packet you are returning.\n// The returned packet can be used as a \"response\" from a sent packet.\npublic class MyMessageHandler implements IMessageHandler<MyMessage, IMessage> {\n  // Do note that the default constructor is required, but implicitly defined in this case\n\n  @Override public IMessage onMessage(MyMessage message, MessageContext ctx) {\n    // This is the player the packet was sent to the server from\n    EntityPlayerMP serverPlayer = ctx.getServerHandler().playerEntity;\n    // The value that was sent\n    int amount = message.toSend;\n    serverPlayer.inventory.addItemStackToInventory(new ItemStack(Items.diamond, amount));\n    // No response packet\n    return null;\n  }\n}\n\n\n\n\nIt is recommended (but not required) that for organization\u2019s sake, this class is an inner class to your MyMessage class. If this is done, note that the class must also be declared \nstatic\n.\n\n\n\n\nWarning\n\n\nAs of Minecraft 1.8 packets are by default handled on the network thread.\n\n\nThat means that your \nIMessageHandler\n can \nnot\n interact with most game objects directly. The example above for example would not be correct.\nMinecraft provides a convenient way to make your code execute on the main thread instead using \nIThreadListener.addScheduledTask\n.\n\n\nThe way to obtain an \nIThreadListener\n is using either the \nMinecraft\n instance (client side) or a \nWorldServer\n instance (server side).\n\n\n\n\nRegistering Packets\n\n\nSo now we have a packet, and a handler for this packet. But the \nSimpleNetworkWrapper\n needs one more thing to function! For it to use a packet, the packet must be registered with an \ndiscriminator\n, which is just an integer used to map packet types between server and client. To do this, call \nINSTANCE.registerMessage(MyMessageHandler.class, MyMessage.class, 0, Side.Server);\n where \nINSTANCE\n is the \nSimpleNetworkWrapper\n we defined earlier.\n\n\nThis is quite a complex method, so lets break it down a bit.\n\n\n\n\nThe first parameter is \nmessageHandler\n, which is the class that handles your packet. This class must always have a default constructor, and should have type bound REQ that matches the next argument.\n\n\nThe second parameter is \nrequestMessageType\n which is the actual packet class. This class must also have a default constructor and match the REQ type bound of the previous param.\n\n\nThe third parameter is the discriminator for the packet. This is a per-channel unique ID for the packet. We recommend you use a static variable to hold the ID, and then call registerMessage using \nid++\n. This will guarantee 100% unique IDs.\n\n\nThe fourth and final parameter is the side that your packet will be \nreceived\n on. If you are planning to send the packet to both sides, it must be registered twice with a \ndifferent\n discriminator.\n\n\n\n\nUsing Packets\n\n\nWhen sending packets, make sure that there is a handler registered \non the receiving side\n for said packet. If there is not, the packet will be sent across the network and then thrown away, resulting in a \u201cleaked\u201d packet. This is harmless other than needless network usage, but should still be fixed.\n\n\nSending to the Server\n\n\nThere is but one way to send a packet to the server. This is because there is only ever \none\n server, and only \none\n way to send to that server, of course. To do so, we must again use that \nSimpleNetworkWrapper\n that was defined earlier. Simply call \nINSTANCE.sendToServer(new MyMessage(toSend))\n. The message will be sent to the \nSide.SERVER\n \nIMessageHandler\n for its type, if one exists.\n\n\nSending to Clients\n\n\nThere are four different methods of sending packets to clients:\n\n\n\n\nsendToAll\n - Calling \nINSTANCE.sendToAll\n will send the packet once to every single player on the current server, no matter what location or dimension they are in.\n\n\nsendToDimension\n - \nINSTANCE.sendToDimension\n takes two arguments, an \nIMessage\n and an integer. The integer is the dimension ID to send to, which can be gotten with \nworld.provider.dimensionID\n. The packet will be sent to all players currently in the given dimension.\n\n\nsendToAllAround\n - \nINSTANCE.sendToAllAround\n requires an \nIMessage\n and a \nNetworkRegistry.TargetPoint\n object. All players within the \nTargetPoint\n will have the packet sent to them. A TargetPoint requires a dimension (see #2), x/y/z coordinates, and a range. It represents a cube in a world.\n\n\nsendTo\n - Finally, there is the option to send to a single client using \nINSTANCE.sendTo\n. This requires an \nIMessage\n and an \nEntityPlayerMP\n to which to send the packet. Note that though this is not the more generic \nEntityPlayer\n, as long as you are on the server you can safely cast any \nEntityPlayer\n to \nEntityPlayerMP\n.",
            "title": "SimpleImpl"
        },
        {
            "location": "/networking/simpleimpl/#simpleimpl",
            "text": "SimpleImpl is the name given to the packet system that revolves around the  SimpleNetworkWrapper  class. Using this system is by far the easiest way to send custom data between clients and the server.",
            "title": "SimpleImpl"
        },
        {
            "location": "/networking/simpleimpl/#getting-started",
            "text": "First you need to create your  SimpleNetworkWrapper  object. We recommend that you do this in a separate class, possibly something like  ModidPacketHandler . Create your  SimpleNetworkWrapper  as a static field in this class, like so:  public static final SimpleNetworkWrapper INSTANCE = NetworkRegistry.INSTANCE.newSimpleChannel(\"mymodid\");  Where  \"mymodid\"  is a short identifier for your packet channel, typically just your mod ID, unless that is unusually long.",
            "title": "Getting Started"
        },
        {
            "location": "/networking/simpleimpl/#making-packets",
            "text": "",
            "title": "Making Packets"
        },
        {
            "location": "/networking/simpleimpl/#imessage",
            "text": "A packet is defined by using the  IMessage  interface. This interface defines 2 methods,  toBytes  and  fromBytes . These methods, respectively, write and read the data in your packet to and from a  ByteBuf  object, which is an object used to hold a stream (array) of bytes which are sent through the network.  For an example, let\u2019s define a small packet that is designed to send a single int over the network:  public class MyMessage implements IMessage {\n  // A default constructor is always required\n  public MyMessage(){}\n\n  private int toSend;\n  public MyMessage(int toSend) {\n    this.toSend = toSend;\n  }\n\n  @Override public void toBytes(ByteBuf buf) {\n    // Writes the int into the buf\n    buf.writeInt(toSend);\n  }\n\n  @Override public void fromBytes(ByteBuf buf) {\n    // Reads the int back from the buf. Note that if you have multiple values, you must read in the same order you wrote.\n    toSend = buf.readInt();\n  }\n}",
            "title": "IMessage"
        },
        {
            "location": "/networking/simpleimpl/#imessagehandler",
            "text": "Now, how can we use this packet? Well, first we must have a class that can  handle  this packet. This is created with the  IMessageHandler  interface. Say we wanted to use this integer we sent to give the player that many diamonds on the server. Let\u2019s make this handler:  // The params of the IMessageHandler are <REQ, REPLY>\n// This means that the first param is the packet you are receiving, and the second is the packet you are returning.\n// The returned packet can be used as a \"response\" from a sent packet.\npublic class MyMessageHandler implements IMessageHandler<MyMessage, IMessage> {\n  // Do note that the default constructor is required, but implicitly defined in this case\n\n  @Override public IMessage onMessage(MyMessage message, MessageContext ctx) {\n    // This is the player the packet was sent to the server from\n    EntityPlayerMP serverPlayer = ctx.getServerHandler().playerEntity;\n    // The value that was sent\n    int amount = message.toSend;\n    serverPlayer.inventory.addItemStackToInventory(new ItemStack(Items.diamond, amount));\n    // No response packet\n    return null;\n  }\n}  It is recommended (but not required) that for organization\u2019s sake, this class is an inner class to your MyMessage class. If this is done, note that the class must also be declared  static .   Warning  As of Minecraft 1.8 packets are by default handled on the network thread.  That means that your  IMessageHandler  can  not  interact with most game objects directly. The example above for example would not be correct.\nMinecraft provides a convenient way to make your code execute on the main thread instead using  IThreadListener.addScheduledTask .  The way to obtain an  IThreadListener  is using either the  Minecraft  instance (client side) or a  WorldServer  instance (server side).",
            "title": "IMessageHandler"
        },
        {
            "location": "/networking/simpleimpl/#registering-packets",
            "text": "So now we have a packet, and a handler for this packet. But the  SimpleNetworkWrapper  needs one more thing to function! For it to use a packet, the packet must be registered with an  discriminator , which is just an integer used to map packet types between server and client. To do this, call  INSTANCE.registerMessage(MyMessageHandler.class, MyMessage.class, 0, Side.Server);  where  INSTANCE  is the  SimpleNetworkWrapper  we defined earlier.  This is quite a complex method, so lets break it down a bit.   The first parameter is  messageHandler , which is the class that handles your packet. This class must always have a default constructor, and should have type bound REQ that matches the next argument.  The second parameter is  requestMessageType  which is the actual packet class. This class must also have a default constructor and match the REQ type bound of the previous param.  The third parameter is the discriminator for the packet. This is a per-channel unique ID for the packet. We recommend you use a static variable to hold the ID, and then call registerMessage using  id++ . This will guarantee 100% unique IDs.  The fourth and final parameter is the side that your packet will be  received  on. If you are planning to send the packet to both sides, it must be registered twice with a  different  discriminator.",
            "title": "Registering Packets"
        },
        {
            "location": "/networking/simpleimpl/#using-packets",
            "text": "When sending packets, make sure that there is a handler registered  on the receiving side  for said packet. If there is not, the packet will be sent across the network and then thrown away, resulting in a \u201cleaked\u201d packet. This is harmless other than needless network usage, but should still be fixed.",
            "title": "Using Packets"
        },
        {
            "location": "/networking/simpleimpl/#sending-to-the-server",
            "text": "There is but one way to send a packet to the server. This is because there is only ever  one  server, and only  one  way to send to that server, of course. To do so, we must again use that  SimpleNetworkWrapper  that was defined earlier. Simply call  INSTANCE.sendToServer(new MyMessage(toSend)) . The message will be sent to the  Side.SERVER   IMessageHandler  for its type, if one exists.",
            "title": "Sending to the Server"
        },
        {
            "location": "/networking/simpleimpl/#sending-to-clients",
            "text": "There are four different methods of sending packets to clients:   sendToAll  - Calling  INSTANCE.sendToAll  will send the packet once to every single player on the current server, no matter what location or dimension they are in.  sendToDimension  -  INSTANCE.sendToDimension  takes two arguments, an  IMessage  and an integer. The integer is the dimension ID to send to, which can be gotten with  world.provider.dimensionID . The packet will be sent to all players currently in the given dimension.  sendToAllAround  -  INSTANCE.sendToAllAround  requires an  IMessage  and a  NetworkRegistry.TargetPoint  object. All players within the  TargetPoint  will have the packet sent to them. A TargetPoint requires a dimension (see #2), x/y/z coordinates, and a range. It represents a cube in a world.  sendTo  - Finally, there is the option to send to a single client using  INSTANCE.sendTo . This requires an  IMessage  and an  EntityPlayerMP  to which to send the packet. Note that though this is not the more generic  EntityPlayer , as long as you are on the server you can safely cast any  EntityPlayer  to  EntityPlayerMP .",
            "title": "Sending to Clients"
        },
        {
            "location": "/datastorage/capabilities/",
            "text": "The Capability System\n\n\nCapabilities allow exposing features in a dynamic and flexible way, without having to resort to directly implementing many interfaces.\n\n\nIn general terms, each capability provides a feature in the form of an interface, alongside with a default implementation which can be requested, and a storage handler for at least this default implementation. The storage handler can support other implementations, but this is up to the capability implementor, so look it up in their documentation before trying to use the default storage with non-default implementations.\n\n\nForge adds capability support to TileEntities, Entities, and ItemStacks, which can be exposed either by attaching them through an event or by overriding the capability methods in your own implementations of the objects. This will be explained in more detail in the following sections.\n\n\nForge-provided Capabilities\n\n\nForge provides three capabilities: IItemHandler, IFluidHandler and IEnergyStorage\n\n\nIItemHandler exposes an interface for handling inventory slots. It can be applied to TileEntities (chests, machines, etc.), Entities (extra player slots, mob/creature inventories/bags), or ItemStacks (portable backpacks and such). It replaces the old \nIInventory\n and \nISidedInventory\n with an automation-friendly system.\n\n\nIFluidHandler exposes an interface for handling fluid inventories. It can also be applied to TileEntities Entities, or ItemStacks. It replaces the old \nIFluidHandler\n with a more consistent and automation-friendly system.\n\n\nIEnergyStorage exposes an interface for handling energy containers. It can be applied to TileEntities, Entities or ItemStacks. It is based on the RedstoneFlux API by TeamCoFH.\n\n\nUsing an Existing Capability\n\n\nAs mentioned earlier, TileEntities, Entities, and ItemStacks implement the capability provider feature, through the \nICapabilityProvider\n interface. This interface adds two methods, \nhasCapability\n and \ngetCapability\n, which can be used to query the capabilities present in the objects.\n\n\nIn order to obtain a capability, you will need to refer it by its unique instance. In the case of the Item Handler, this capability is primarily stored in \nCapabilityItemHandler.ITEM_HANDLER_CAPABILITY\n, but it is possible to get other instance references by using the \n@CapabilityInject\n annotation.\n\n\n@CapabilityInject(IItemHandler.class)\nstatic Capability<IItemHandler> ITEM_HANDLER_CAPABILITY = null;\n\n\n\n\nThis annotation can be applied to fields and methods. When applied to a field, it will assign the instance of the capability (the same one gets assigned to all fields) upon registration of the capability, and left to the existing value (\nnull\n), if the capability was never registered. Because local static field accesses are fast, it is a good idea to keep your own local copy of the reference for objects that work with capabilities. This annotation can also be used on a method, in order to get notified when a capability is registered, so that certain features can be enabled conditionally.\n\n\nBoth the \nhasCapability\n and \ngetCapability\n methods have a second parameter, of type EnumFacing, which can be used in the to request the specific instance for that one face. If passed \nnull\n, it can be assumed that the request comes either from within the block, or from some place where the side has no meaning, such as a different dimension. In this case a general capability instance that does not care about sides will be requested instead. The return type of \ngetCapability\n will correspond to the type declared in the capability passed to the method. For the Item Handler capability, this is indeed \nIItemHandler\n.\n\n\nExposing a Capability\n\n\nIn order to expose a capability, you will first need an instance of the underlying capability type. Note that you should assign a separate instance to each object that keeps the capability, since the capability will most probably be tied to the containing object.\n\n\nThere\u2019s two ways to obtain such an instance, through the Capability itself, or by explicitly instantiating an implementation of it. The first method is designed to use a default implementation, if those default values are useful for you. In the case of the Item Handler capability, the default implementation will expose a single slot inventory, which is most probably not what you want.\n\n\nThe second method can be used to provide custom implementations. In the case of \nIItemHandler\n, the default implementation uses the \nItemStackHandler\n class, which has an optional argument in the constructor, to specify a number of slots. However, relying on the existence of these default implementations should be avoided, as the purpose of the capability system is to prevent loading errors in contexts where the capability is not present, so instantiation should be protected behind a check testing if the capability has been registered (see the remarks about \n@CapabilityInject\n in the previous section).\n\n\nOnce you have your own instance of the capability interface, you will want to notify users of the capability system that you expose this capability. This is done by overriding the \nhasCapability\n method, and comparing the instance with the capability you are exposing. If your machine has different slots based on which side is being queried, you can test this with the \nfacing\n parameter. For Entities and ItemStacks, this parameter can be ignored, but it is still possible to have side as a context, such as different armor slots on a player (top side => head slot?), or about the surrounding blocks in the inventory (west => slot on the left?). Don\u2019t forget to fall back to \nsuper\n, otherwise the attached capabilities will stop working.\n\n\n@Override\npublic boolean hasCapability(Capability<?> capability, EnumFacing facing) {\n  if (capability == CapabilityItemHandler.ITEM_HANDLER_CAPABILITY) {\n    return true;\n  }\n  return super.hasCapability(capability, facing);\n}\n\n\n\n\nSimilarly, you will want to provide the interface reference to your capability instance, when requested. Again, don\u2019t forget to fall back to \nsuper\n.\n\n\n@Override\npublic <T> T getCapability(Capability<T> capability, EnumFacing facing) {\n  if (capability == CapabilityItemHandler.ITEM_HANDLER_CAPABILITY) {\n    return (T) inventory;\n  }\n  return super.getCapability(capability, facing);\n}\n\n\n\n\nIt is strongly suggested that direct checks in code are used to test for capabilities instead of attempting to rely on maps other other data structures, since capability tests can be done by many objects every tick, and they need to be as fast as possible in order to avoid slowing down the game.\n\n\nAttaching Capabilities\n\n\nAs mentioned, attaching capabilities to entities and itemstacks can be done using \nAttachCapabilityEvent\n. The same event is used for all objects that can provide capabilities. \nAttachCapabilityEvent\n has 4 valid generic types providing the following events:\n\n\n\n\nAttachCapabilityEvent<Entity>\n: Fires only for entities.\n\n\nAttachCapabilityEvent<TileEntity>\n: Fires only for tile entities.\n\n\nAttachCapabilityEvent<Item>\n: Fires only for item stacks.\n\n\nAttachCapabilityEvent<World>\n: Fires only for worlds.\n\n\n\n\nThe generic type cannot be more specific than the above types. For example: If you want to attach capabilities to \nEntityPlayer\n, you have to subscribe to the \nAttachCapabilityEvent<Entity>\n, and then determine that the provided object is an \nEntityPlayer\n before attaching the capability.\n\n\nIn all cases, the event has a method \naddCapability\n, which can be used to attach capabilities to the target object. Instead of adding capabilities themselves to the list, you add capability providers, which have the chance to return capabilities only from certain sides. While the provider only needs to implement \nICapabilityProvider\n, if the capability needs to store data persistently it is possible to implement \nICapabilitySerializable<T extends NBTBase>\n which, on top of returning the capabilities, will allow providing NBT save/load functions.\n\n\nFor information on how to implement \nICapabilityProvider\n, refer to the \nExposing a Capability\n section.\n\n\nCreating Your Own Capability\n\n\nIn general terms, a capability is declared and registered through a single method call to \nCapabilityManager.INSTANCE.register()\n. One possibility is to define a static \nregister()\n method inside a dedicated class for the capability, but this is not required by the capability system. For the purpose of this documentation we will be describing each part as a separate named class, although anonymous classes are an option.\n\n\nCapabilityManager.INSTANCE.register(capability interface class, storage, default implementation factory);\n\n\n\n\nThe first parameter to this method, is the type that describes the capability feature. In our example, this will be \nIExampleCapability.class\n.\n\n\nThe second parameter is an instance of a class that implements \nCapability.IStorage<T>\n, where T is the same class we specified in the first parameter. This storage class will help manage saving and loading for the default implementation, and it can, optionally, also support other implementations.\n\n\nprivate static class Storage\n    implements Capability.IStorage<IExampleCapability> {\n\n  @Override\n  public NBTBase writeNBT(Capability<IExampleCapability> capability, IExampleCapability instance, EnumFacing side) {\n    // return an NBT tag\n  }\n\n  @Override\n  public void readNBT(Capability<IExampleCapability> capability, IExampleCapability instance, EnumFacing side, NBTBase nbt) {\n    // load from the NBT tag\n  }\n}\n\n\n\n\nThe last parameter is a callable factory that will return new instances of the default implementation.\n\n\nprivate static class Factory implements Callable<IExampleCapability> {\n\n  @Override\n  public IExampleCapability call() throws Exception {\n    return new Implementation();\n  }\n}\n\n\n\n\nFinally, we will need the default implementation itself, to be able to instantiate it in the factory. Designing this class is up to you, but it should at least provide a basic skeleton that people can use to test the capability, if it\u2019s not a fully usable implementation on itself.\n\n\nSynchronizing Data with Clients\n\n\nBy default, Capability data is not sent to clients. In order to change this, the mods have to manage their own synchronization code using packets.\n\n\nThere are three different situation in which you may want to send synchronization packets, all of them optional:\n\n\n\n\nWhen the entity spawns in the world, or the block is placed, you may want to share the initialization-assigned values with the clients.\n\n\nWhen the stored data changes, you may want to notify some or all of the watching clients.\n\n\nWhen a new client starts viewing the entity or block, you may want to notify it of the existing data.\n\n\n\n\nRefer to the \nNetworking\n page for more information on implementing network packets.\n\n\nPersisting across Player Deaths\n\n\nBy default, the capability data does not persist on death. In order to change this, the data has to be manually copied when the player entity is cloned during the respawn process.\n\n\nThis can be done by handling the \nPlayerEvent.Clone\n event, reading the data from the original entity, and assigning it to the new entity. In this event, the \nwasDead\n field can be used to distinguish between respawning after death, and returning from the End. This is important because the data will already exist when returning from the End, so care has to be taken to not duplicate values in this case.\n\n\nMigrating from IExtendedEntityProperties\n\n\nAlthough the Capability system can do everything IEEPs (IExtendedEntityProperties) did and more, the two concepts don\u2019t fully match 1:1. In this section, I will explain how to convert existing IEEPs into Capabilities.\n\n\nThis is a quick list of IEEP concepts and their Capability equivalent:\n\n\n\n\nProperty name/id (\nString\n): Capability key (\nResourceLocation\n)\n\n\nRegistration (\nEntityConstructing\n): Attaching (\nAttachCapabilityEvent<Entity>\n), the real registration of the Capability happens during pre-init.\n\n\nNBT read/write methods: Does not happen automatically. Attach an \nICapabilitySerializable\n in the event, and run the read/write methods from the \nserializeNBT\n/\ndeserializeNBT\n.\n\n\n\n\nFeatures you probably will not need (if the IEEP was for internal use only):\n\n\n\n\nThe Capability system provides a default implementation concept, meant to simplify usage by third party consumers, but it doesn\u2019t really make much sense for an internal Capability designed to replace an IEEP. You can safely return \nnull\n from the factory if the capability is be for internal use only.\n\n\nThe Capability system provides an \nIStorage\n system that can be used to read/write data from those default implementations, if you choose not to provide default implementations, then the IStorage system will never get called, and can be left blank.\n\n\n\n\nThe following steps assume you have read the rest of the document, and you understand the concepts of the capability system.\n\n\nQuick conversion guide:\n\n\n\n\nConvert the IEEP key/id string into a \nResourceLocation\n (which will use your MODID as a domain).\n\n\nIn your handler class (not the class that implements your capability interface), create a field that will hold the Capability instance.\n\n\nChange the \nEntityConstructing\n event to \nAttachCapabilityEvent\n, and instead of querying the IEEP, you will want to attach an \nICapabilityProvider\n (probably \nICapabilitySerializable\n, which allows saving/loading from NBT).\n\n\nCreate a registration method if you don\u2019t have one (you may have one where you registered your IEEP\u2019s event handlers) and in it, run the capability registration function.",
            "title": "Capabilities"
        },
        {
            "location": "/datastorage/capabilities/#the-capability-system",
            "text": "Capabilities allow exposing features in a dynamic and flexible way, without having to resort to directly implementing many interfaces.  In general terms, each capability provides a feature in the form of an interface, alongside with a default implementation which can be requested, and a storage handler for at least this default implementation. The storage handler can support other implementations, but this is up to the capability implementor, so look it up in their documentation before trying to use the default storage with non-default implementations.  Forge adds capability support to TileEntities, Entities, and ItemStacks, which can be exposed either by attaching them through an event or by overriding the capability methods in your own implementations of the objects. This will be explained in more detail in the following sections.",
            "title": "The Capability System"
        },
        {
            "location": "/datastorage/capabilities/#forge-provided-capabilities",
            "text": "Forge provides three capabilities: IItemHandler, IFluidHandler and IEnergyStorage  IItemHandler exposes an interface for handling inventory slots. It can be applied to TileEntities (chests, machines, etc.), Entities (extra player slots, mob/creature inventories/bags), or ItemStacks (portable backpacks and such). It replaces the old  IInventory  and  ISidedInventory  with an automation-friendly system.  IFluidHandler exposes an interface for handling fluid inventories. It can also be applied to TileEntities Entities, or ItemStacks. It replaces the old  IFluidHandler  with a more consistent and automation-friendly system.  IEnergyStorage exposes an interface for handling energy containers. It can be applied to TileEntities, Entities or ItemStacks. It is based on the RedstoneFlux API by TeamCoFH.",
            "title": "Forge-provided Capabilities"
        },
        {
            "location": "/datastorage/capabilities/#using-an-existing-capability",
            "text": "As mentioned earlier, TileEntities, Entities, and ItemStacks implement the capability provider feature, through the  ICapabilityProvider  interface. This interface adds two methods,  hasCapability  and  getCapability , which can be used to query the capabilities present in the objects.  In order to obtain a capability, you will need to refer it by its unique instance. In the case of the Item Handler, this capability is primarily stored in  CapabilityItemHandler.ITEM_HANDLER_CAPABILITY , but it is possible to get other instance references by using the  @CapabilityInject  annotation.  @CapabilityInject(IItemHandler.class)\nstatic Capability<IItemHandler> ITEM_HANDLER_CAPABILITY = null;  This annotation can be applied to fields and methods. When applied to a field, it will assign the instance of the capability (the same one gets assigned to all fields) upon registration of the capability, and left to the existing value ( null ), if the capability was never registered. Because local static field accesses are fast, it is a good idea to keep your own local copy of the reference for objects that work with capabilities. This annotation can also be used on a method, in order to get notified when a capability is registered, so that certain features can be enabled conditionally.  Both the  hasCapability  and  getCapability  methods have a second parameter, of type EnumFacing, which can be used in the to request the specific instance for that one face. If passed  null , it can be assumed that the request comes either from within the block, or from some place where the side has no meaning, such as a different dimension. In this case a general capability instance that does not care about sides will be requested instead. The return type of  getCapability  will correspond to the type declared in the capability passed to the method. For the Item Handler capability, this is indeed  IItemHandler .",
            "title": "Using an Existing Capability"
        },
        {
            "location": "/datastorage/capabilities/#exposing-a-capability",
            "text": "In order to expose a capability, you will first need an instance of the underlying capability type. Note that you should assign a separate instance to each object that keeps the capability, since the capability will most probably be tied to the containing object.  There\u2019s two ways to obtain such an instance, through the Capability itself, or by explicitly instantiating an implementation of it. The first method is designed to use a default implementation, if those default values are useful for you. In the case of the Item Handler capability, the default implementation will expose a single slot inventory, which is most probably not what you want.  The second method can be used to provide custom implementations. In the case of  IItemHandler , the default implementation uses the  ItemStackHandler  class, which has an optional argument in the constructor, to specify a number of slots. However, relying on the existence of these default implementations should be avoided, as the purpose of the capability system is to prevent loading errors in contexts where the capability is not present, so instantiation should be protected behind a check testing if the capability has been registered (see the remarks about  @CapabilityInject  in the previous section).  Once you have your own instance of the capability interface, you will want to notify users of the capability system that you expose this capability. This is done by overriding the  hasCapability  method, and comparing the instance with the capability you are exposing. If your machine has different slots based on which side is being queried, you can test this with the  facing  parameter. For Entities and ItemStacks, this parameter can be ignored, but it is still possible to have side as a context, such as different armor slots on a player (top side => head slot?), or about the surrounding blocks in the inventory (west => slot on the left?). Don\u2019t forget to fall back to  super , otherwise the attached capabilities will stop working.  @Override\npublic boolean hasCapability(Capability<?> capability, EnumFacing facing) {\n  if (capability == CapabilityItemHandler.ITEM_HANDLER_CAPABILITY) {\n    return true;\n  }\n  return super.hasCapability(capability, facing);\n}  Similarly, you will want to provide the interface reference to your capability instance, when requested. Again, don\u2019t forget to fall back to  super .  @Override\npublic <T> T getCapability(Capability<T> capability, EnumFacing facing) {\n  if (capability == CapabilityItemHandler.ITEM_HANDLER_CAPABILITY) {\n    return (T) inventory;\n  }\n  return super.getCapability(capability, facing);\n}  It is strongly suggested that direct checks in code are used to test for capabilities instead of attempting to rely on maps other other data structures, since capability tests can be done by many objects every tick, and they need to be as fast as possible in order to avoid slowing down the game.",
            "title": "Exposing a Capability"
        },
        {
            "location": "/datastorage/capabilities/#attaching-capabilities",
            "text": "As mentioned, attaching capabilities to entities and itemstacks can be done using  AttachCapabilityEvent . The same event is used for all objects that can provide capabilities.  AttachCapabilityEvent  has 4 valid generic types providing the following events:   AttachCapabilityEvent<Entity> : Fires only for entities.  AttachCapabilityEvent<TileEntity> : Fires only for tile entities.  AttachCapabilityEvent<Item> : Fires only for item stacks.  AttachCapabilityEvent<World> : Fires only for worlds.   The generic type cannot be more specific than the above types. For example: If you want to attach capabilities to  EntityPlayer , you have to subscribe to the  AttachCapabilityEvent<Entity> , and then determine that the provided object is an  EntityPlayer  before attaching the capability.  In all cases, the event has a method  addCapability , which can be used to attach capabilities to the target object. Instead of adding capabilities themselves to the list, you add capability providers, which have the chance to return capabilities only from certain sides. While the provider only needs to implement  ICapabilityProvider , if the capability needs to store data persistently it is possible to implement  ICapabilitySerializable<T extends NBTBase>  which, on top of returning the capabilities, will allow providing NBT save/load functions.  For information on how to implement  ICapabilityProvider , refer to the  Exposing a Capability  section.",
            "title": "Attaching Capabilities"
        },
        {
            "location": "/datastorage/capabilities/#creating-your-own-capability",
            "text": "In general terms, a capability is declared and registered through a single method call to  CapabilityManager.INSTANCE.register() . One possibility is to define a static  register()  method inside a dedicated class for the capability, but this is not required by the capability system. For the purpose of this documentation we will be describing each part as a separate named class, although anonymous classes are an option.  CapabilityManager.INSTANCE.register(capability interface class, storage, default implementation factory);  The first parameter to this method, is the type that describes the capability feature. In our example, this will be  IExampleCapability.class .  The second parameter is an instance of a class that implements  Capability.IStorage<T> , where T is the same class we specified in the first parameter. This storage class will help manage saving and loading for the default implementation, and it can, optionally, also support other implementations.  private static class Storage\n    implements Capability.IStorage<IExampleCapability> {\n\n  @Override\n  public NBTBase writeNBT(Capability<IExampleCapability> capability, IExampleCapability instance, EnumFacing side) {\n    // return an NBT tag\n  }\n\n  @Override\n  public void readNBT(Capability<IExampleCapability> capability, IExampleCapability instance, EnumFacing side, NBTBase nbt) {\n    // load from the NBT tag\n  }\n}  The last parameter is a callable factory that will return new instances of the default implementation.  private static class Factory implements Callable<IExampleCapability> {\n\n  @Override\n  public IExampleCapability call() throws Exception {\n    return new Implementation();\n  }\n}  Finally, we will need the default implementation itself, to be able to instantiate it in the factory. Designing this class is up to you, but it should at least provide a basic skeleton that people can use to test the capability, if it\u2019s not a fully usable implementation on itself.",
            "title": "Creating Your Own Capability"
        },
        {
            "location": "/datastorage/capabilities/#synchronizing-data-with-clients",
            "text": "By default, Capability data is not sent to clients. In order to change this, the mods have to manage their own synchronization code using packets.  There are three different situation in which you may want to send synchronization packets, all of them optional:   When the entity spawns in the world, or the block is placed, you may want to share the initialization-assigned values with the clients.  When the stored data changes, you may want to notify some or all of the watching clients.  When a new client starts viewing the entity or block, you may want to notify it of the existing data.   Refer to the  Networking  page for more information on implementing network packets.",
            "title": "Synchronizing Data with Clients"
        },
        {
            "location": "/datastorage/capabilities/#persisting-across-player-deaths",
            "text": "By default, the capability data does not persist on death. In order to change this, the data has to be manually copied when the player entity is cloned during the respawn process.  This can be done by handling the  PlayerEvent.Clone  event, reading the data from the original entity, and assigning it to the new entity. In this event, the  wasDead  field can be used to distinguish between respawning after death, and returning from the End. This is important because the data will already exist when returning from the End, so care has to be taken to not duplicate values in this case.",
            "title": "Persisting across Player Deaths"
        },
        {
            "location": "/datastorage/capabilities/#migrating-from-iextendedentityproperties",
            "text": "Although the Capability system can do everything IEEPs (IExtendedEntityProperties) did and more, the two concepts don\u2019t fully match 1:1. In this section, I will explain how to convert existing IEEPs into Capabilities.  This is a quick list of IEEP concepts and their Capability equivalent:   Property name/id ( String ): Capability key ( ResourceLocation )  Registration ( EntityConstructing ): Attaching ( AttachCapabilityEvent<Entity> ), the real registration of the Capability happens during pre-init.  NBT read/write methods: Does not happen automatically. Attach an  ICapabilitySerializable  in the event, and run the read/write methods from the  serializeNBT / deserializeNBT .   Features you probably will not need (if the IEEP was for internal use only):   The Capability system provides a default implementation concept, meant to simplify usage by third party consumers, but it doesn\u2019t really make much sense for an internal Capability designed to replace an IEEP. You can safely return  null  from the factory if the capability is be for internal use only.  The Capability system provides an  IStorage  system that can be used to read/write data from those default implementations, if you choose not to provide default implementations, then the IStorage system will never get called, and can be left blank.   The following steps assume you have read the rest of the document, and you understand the concepts of the capability system.  Quick conversion guide:   Convert the IEEP key/id string into a  ResourceLocation  (which will use your MODID as a domain).  In your handler class (not the class that implements your capability interface), create a field that will hold the Capability instance.  Change the  EntityConstructing  event to  AttachCapabilityEvent , and instead of querying the IEEP, you will want to attach an  ICapabilityProvider  (probably  ICapabilitySerializable , which allows saving/loading from NBT).  Create a registration method if you don\u2019t have one (you may have one where you registered your IEEP\u2019s event handlers) and in it, run the capability registration function.",
            "title": "Migrating from IExtendedEntityProperties"
        },
        {
            "location": "/datastorage/worldsaveddata/",
            "text": "World Saved Data\n\n\nThe World Saved Data system allows attaching data to worlds, either per dimension, or global.\n\n\nDeclaration\n\n\nThe basis of the system is the \nWorldSavedData\n class. This class provides the basic methods used to manage the data:\n\n\n\n\nwriteToNBT\n: Allows the implementation to write data to the world.\n\n\nreadFromNBT\n: Allows the implementation to load previously saved data.\n\n\nmarkDirty\n: This method is not overridden by the implementation. Instead, it must be called after changing the data, to notify Minecraft that there are changes that need to be written. If not called, the existing data will be kept instead, and \nwriteToNBT\n will not get called.\n\n\n\n\nAn implementation will override this class, and instances of this implementation will be attached to the \nWorld\n objects, ready to store any required data.\n\n\nA basic skeleton may look like this:\n\n\npublic class ExampleWorldSavedData extends WorldSavedData {\n  private static final String DATA_NAME = MODID + \"_ExampleData\";\n\n  // Required constructors\n  public ExampleWorldSavedData() {\n    super(DATA_NAME);\n  }\n  public ExampleWorldSavedData(String s) {\n    super(s);\n  }\n\n  // WorldSavedData methods\n}\n\n\n\n\nRegistration and Usage\n\n\nThe WorldSavedData is loaded and/or attached to the world on demand. A good practice is to create a static get method that will load the data, and if not present, attach a new instance.\n\n\nThere are two ways to attach the data: per dimension, or globally. Global data will be attached to a shared map, that will be obtainable from any instance of the World class, while per-world data will not be shared across dimensions. Keep in mind the separation between client and server, as they get separate instances of global data, so if data is needed on both sides, manual synchronization will be required.\n\n\nIn code, these storage locations are represented by two instances of \nMapStorage\n present in the World object. The global data is obtained from \nWorld#getMapStorage()\n, while the per-world map is obtained from \nWorld#getPerWorldStorage()\n.\n\n\nThe existing data can be obtained using \nMapStorage#getOrLoadData\n, and new data can be attached using \nMapStorage#setData\n.\n\n\npublic static ExampleWorldSavedData get(World world) {\n  // The IS_GLOBAL constant is there for clarity, and should be simplified into the right branch.\n  MapStorage storage = IS_GLOBAL ? world.getMapStorage() : world.getPerWorldStorage();\n  ExampleWorldSavedData instance = (ExampleWorldSavedData) storage.getOrLoadData(ExampleWorldSavedData.class, DATA_NAME);\n\n  if (instance == null) {\n    instance = new ExampleWorldSavedData();\n    storage.setData(DATA_NAME, instance);\n  }\n  return instance;\n}",
            "title": "World Saved Data"
        },
        {
            "location": "/datastorage/worldsaveddata/#world-saved-data",
            "text": "The World Saved Data system allows attaching data to worlds, either per dimension, or global.",
            "title": "World Saved Data"
        },
        {
            "location": "/datastorage/worldsaveddata/#declaration",
            "text": "The basis of the system is the  WorldSavedData  class. This class provides the basic methods used to manage the data:   writeToNBT : Allows the implementation to write data to the world.  readFromNBT : Allows the implementation to load previously saved data.  markDirty : This method is not overridden by the implementation. Instead, it must be called after changing the data, to notify Minecraft that there are changes that need to be written. If not called, the existing data will be kept instead, and  writeToNBT  will not get called.   An implementation will override this class, and instances of this implementation will be attached to the  World  objects, ready to store any required data.  A basic skeleton may look like this:  public class ExampleWorldSavedData extends WorldSavedData {\n  private static final String DATA_NAME = MODID + \"_ExampleData\";\n\n  // Required constructors\n  public ExampleWorldSavedData() {\n    super(DATA_NAME);\n  }\n  public ExampleWorldSavedData(String s) {\n    super(s);\n  }\n\n  // WorldSavedData methods\n}",
            "title": "Declaration"
        },
        {
            "location": "/datastorage/worldsaveddata/#registration-and-usage",
            "text": "The WorldSavedData is loaded and/or attached to the world on demand. A good practice is to create a static get method that will load the data, and if not present, attach a new instance.  There are two ways to attach the data: per dimension, or globally. Global data will be attached to a shared map, that will be obtainable from any instance of the World class, while per-world data will not be shared across dimensions. Keep in mind the separation between client and server, as they get separate instances of global data, so if data is needed on both sides, manual synchronization will be required.  In code, these storage locations are represented by two instances of  MapStorage  present in the World object. The global data is obtained from  World#getMapStorage() , while the per-world map is obtained from  World#getPerWorldStorage() .  The existing data can be obtained using  MapStorage#getOrLoadData , and new data can be attached using  MapStorage#setData .  public static ExampleWorldSavedData get(World world) {\n  // The IS_GLOBAL constant is there for clarity, and should be simplified into the right branch.\n  MapStorage storage = IS_GLOBAL ? world.getMapStorage() : world.getPerWorldStorage();\n  ExampleWorldSavedData instance = (ExampleWorldSavedData) storage.getOrLoadData(ExampleWorldSavedData.class, DATA_NAME);\n\n  if (instance == null) {\n    instance = new ExampleWorldSavedData();\n    storage.setData(DATA_NAME, instance);\n  }\n  return instance;\n}",
            "title": "Registration and Usage"
        },
        {
            "location": "/datastorage/extendedentityproperties/",
            "text": "Extended Entity Properties\n\n\nExtended entity properties allow attaching data to entities.\n\n\n\n\nWarning\n\n\nThis system has been \ndeprecated\n in favor of the \nCapability\n system.\n\n\n\n\nDeclaration and Registration\n\n\nThe basis of the EEPs is the \nIExtendedEntityProperties\n interface. This interface provides the basic methods required for managing the extended data:\n\n\n\n\ninit\n: Allows the implementation to have knowledge about the entity it\u2019s attached to, and the world this entity is loaded into.\n\n\nsaveNBTData\n: Allows the implementation to store data in the save file, to be loaded when the entity gets loaded into the world.\n\n\nloadNBTData\n: Allows the implementation to read the previously saved data for this entity.\n\n\n\n\nAn implementation will have a class implementing this interface, and instances of this class will be attached to the entities, ready to store any required data.\n\n\nThe implementation will need to make use of events in order to attach the IEEP to entities, and optionally any other required features. To help with encapsulation, you may want to create an inner class for handling those events. In the example, I created a \nregister()\n method to help with that.\n\n\nA basic skeleton to get started:\n\n\npublic class ExampleEntityProperty implements IExtendedEntityProperties {\n  public static final String PROP_NAME = ExampleMod.MODID + \"_ExampleEntityData\";\n\n  public static void register() {\n    MinecraftForge.EVENT_BUS.register(new Handler());\n  }\n\n  // IExtendedEntityProperties methods go here\n\n  public static class Handler {\n    // Event handlers will go here\n  }\n}\n\n\n\n\nAttaching the Implementation to Entities\n\n\nIn order to attach the extended property to an entity, it is done by handling the \nEntityEvent.EntityConstructing\n event, and if the entity is of interest, using the \nEntity#registerExtendedProperties\n method.\n\n\nIn order to uniquely identify your property and avoid duplication, the method takes a string parameter with an identifier for the property. A good practice is to include the modid in this string, so that it will not collide with other mods.\n\n\n\n\nWarning\n\n\nIf the same property identifier is added twice, Forge will append a number to it, and return this modified identifier from the \nregisterExtendedProperties\n method. If you don\u2019t want that to happen, you can use \nEntity#getExtendedProperties\n to check if an IEEP with that name was already added.\n\n\n\n\nIn order to handle this event, you could do something like this:\n\n\n@SubscribeEvent\npublic void entityConstruct(EntityEvent.EntityConstructing e) {\n  if (e.entity instanceof EntityPlayer) {\n    if (e.entity.getExtendedProperties(PROP_NAME) == null) {\n      e.entity.registerExtendedProperties(PROP_NAME, new ExampleEntityProperty());\n    }\n  }\n}\n\n\n\n\nMaking Use of the Implementation\n\n\nTo make use of the extended data, the instance of the IEEP implementation has to be obtained from the Entity, and because the entity could have been unloaded or may have changed dimensions, it is not safe to cache the references.\n\n\nTo obtain the IEEP reference, one would use \nEntity#getExtendedProperties\n, with the same property ID specified on registration. The return value, if not \nnull\n, is the instance of \nIExtendedEntityProperties\n added during entity construction.\n\n\nA good idea is to create a static \nget\n method in your IEEP implementation, that will automatically obtain the instance, and cast it to your implementation class. It can be as simple as:\n\n\npublic static ExampleEntityProperty get(Entity p) {\n  return (ExampleEntityProperty) p.getExtendedProperties(PROP_NAME);\n}\n\n\n\n\nSaving and Loading Data from NBT\n\n\nForge allows all IEEPs attached to an entity to save and load themselves. However, keep in mind that the NBT tag provided in the \nsaveNBTData\n and \nloadNBTData\n methods is a global tag for the entity, and may contain data for other IEEPs, along with all the data from the entity itself.\n\n\nThere are some cases where an IEEP may benefit from accessing this global data, but for the most common use cases, it is important to avoid colliding with existing data, preferably by storing the data in a nested tag, using an unique name for it (such as the name used to identify the IEEP).\n\n\nYour code may look a bit like this:\n\n\n@Override\npublic void saveNBTData(NBTTagCompound compound) {\n  NBTTagCompound propertyData = new NBTTagCompound();\n\n  // Write data to propertyData\n\n  compound.setTag(PROP_NAME, propertyData);\n}\n\n@Override\npublic void loadNBTData(NBTTagCompound compound) {\n  if(compound.hasKey(PROP_NAME, Constants.NBT.TAG_COMPOUND)) {\n    NBTTagCompound propertyData = compound.getCompoundTag(PROP_NAME);\n\n    // Read data from propertyData\n  }\n}\n\n\n\n\nSynchronizing Data with Clients\n\n\nBy default, the entity data is not sent to clients. In order to change this, the mods have to manage their own synchronization code using packets.\n\n\nThere are three different situation in which you may want to send synchronization packets, all of them optional:\n\n\n\n\nWhen the entity spawns in the world, you may want to share the initialization-assigned values with the clients.\n\n\nWhen the stored data changes, you may want to notify some or all of the watching clients.\n\n\nWhen a new client starts viewing the entity, you may want to notify it of the existing data.\n\n\n\n\nRefer to the \nNetworking\n page for more information on implementing the network packets.\n\n\nFor example:\n\n\nprivate void dataChanged() {\n  if(!world.isRemote) {\n    EntityTracker tracker = ((WorldServer)world).getEntityTracker();\n    ExampleEntityPropertySync message = new ExampleEntityPropertySync(this);\n\n    for (EntityPlayer entityPlayer : tracker.getTrackingPlayers(entity)) {\n      ExampleMod.channel.sendTo(message, (EntityPlayerMP)entityPlayer);\n    }\n  }\n}\n\nprivate void entitySpawned() {\n  dataChanged();\n}\n\nprivate void playerStartedTracking(EntityPlayer entityPlayer) {\n  ExampleMod.channel.sendTo(new ExampleEntityPropertySync(this), (EntityPlayerMP)entityPlayer);\n}\n\n\n\n\nAnd the corresponding event handlers:\n\n\n@SubscribeEvent\npublic void entityJoinWorld(EntityJoinWorldEvent e) {\n  ExampleEntityProperty data = ExampleEntityProperty.get(e.entity);\n  if (data != null)\n    data.entitySpawned();\n}\n\n@SubscribeEvent\npublic void playerStartedTracking(PlayerEvent.StartTracking e) {\n  ExampleEntityProperty data = ExampleEntityProperty.get(e.target);\n  if (data != null)\n    data.playerStartedTracking(e.entityPlayer);\n}\n\n\n\n\nPersisting across Player Deaths\n\n\nBy default, the entity data does not persist on death. In order to change this, the data has to be manually copied when the player entity is cloned during the respawn process.\n\n\nThis can be done by handling the \nPlayerEvent.Clone\n event. In this event, the \nwasDead\n field can be used to distinguish between respawning after death, and returning from the End. This is important because the data will already exist, so care has to be taken to not duplicate values when returning from the End dimension.\n\n\n@SubscribeEvent\npublic void onClonePlayer(PlayerEvent.Clone e) {\n  if(e.wasDeath) {\n    NBTTagCompound compound = new NBTTagCompound();\n    ExampleEntityProperty.get(e.original).saveNBTData(compound);\n    ExampleEntityProperty.get(e.entityPlayer).loadNBTData(compound);\n  }\n}",
            "title": "Extended Entity Properties"
        },
        {
            "location": "/datastorage/extendedentityproperties/#extended-entity-properties",
            "text": "Extended entity properties allow attaching data to entities.   Warning  This system has been  deprecated  in favor of the  Capability  system.",
            "title": "Extended Entity Properties"
        },
        {
            "location": "/datastorage/extendedentityproperties/#declaration-and-registration",
            "text": "The basis of the EEPs is the  IExtendedEntityProperties  interface. This interface provides the basic methods required for managing the extended data:   init : Allows the implementation to have knowledge about the entity it\u2019s attached to, and the world this entity is loaded into.  saveNBTData : Allows the implementation to store data in the save file, to be loaded when the entity gets loaded into the world.  loadNBTData : Allows the implementation to read the previously saved data for this entity.   An implementation will have a class implementing this interface, and instances of this class will be attached to the entities, ready to store any required data.  The implementation will need to make use of events in order to attach the IEEP to entities, and optionally any other required features. To help with encapsulation, you may want to create an inner class for handling those events. In the example, I created a  register()  method to help with that.  A basic skeleton to get started:  public class ExampleEntityProperty implements IExtendedEntityProperties {\n  public static final String PROP_NAME = ExampleMod.MODID + \"_ExampleEntityData\";\n\n  public static void register() {\n    MinecraftForge.EVENT_BUS.register(new Handler());\n  }\n\n  // IExtendedEntityProperties methods go here\n\n  public static class Handler {\n    // Event handlers will go here\n  }\n}",
            "title": "Declaration and Registration"
        },
        {
            "location": "/datastorage/extendedentityproperties/#attaching-the-implementation-to-entities",
            "text": "In order to attach the extended property to an entity, it is done by handling the  EntityEvent.EntityConstructing  event, and if the entity is of interest, using the  Entity#registerExtendedProperties  method.  In order to uniquely identify your property and avoid duplication, the method takes a string parameter with an identifier for the property. A good practice is to include the modid in this string, so that it will not collide with other mods.   Warning  If the same property identifier is added twice, Forge will append a number to it, and return this modified identifier from the  registerExtendedProperties  method. If you don\u2019t want that to happen, you can use  Entity#getExtendedProperties  to check if an IEEP with that name was already added.   In order to handle this event, you could do something like this:  @SubscribeEvent\npublic void entityConstruct(EntityEvent.EntityConstructing e) {\n  if (e.entity instanceof EntityPlayer) {\n    if (e.entity.getExtendedProperties(PROP_NAME) == null) {\n      e.entity.registerExtendedProperties(PROP_NAME, new ExampleEntityProperty());\n    }\n  }\n}",
            "title": "Attaching the Implementation to Entities"
        },
        {
            "location": "/datastorage/extendedentityproperties/#making-use-of-the-implementation",
            "text": "To make use of the extended data, the instance of the IEEP implementation has to be obtained from the Entity, and because the entity could have been unloaded or may have changed dimensions, it is not safe to cache the references.  To obtain the IEEP reference, one would use  Entity#getExtendedProperties , with the same property ID specified on registration. The return value, if not  null , is the instance of  IExtendedEntityProperties  added during entity construction.  A good idea is to create a static  get  method in your IEEP implementation, that will automatically obtain the instance, and cast it to your implementation class. It can be as simple as:  public static ExampleEntityProperty get(Entity p) {\n  return (ExampleEntityProperty) p.getExtendedProperties(PROP_NAME);\n}",
            "title": "Making Use of the Implementation"
        },
        {
            "location": "/datastorage/extendedentityproperties/#saving-and-loading-data-from-nbt",
            "text": "Forge allows all IEEPs attached to an entity to save and load themselves. However, keep in mind that the NBT tag provided in the  saveNBTData  and  loadNBTData  methods is a global tag for the entity, and may contain data for other IEEPs, along with all the data from the entity itself.  There are some cases where an IEEP may benefit from accessing this global data, but for the most common use cases, it is important to avoid colliding with existing data, preferably by storing the data in a nested tag, using an unique name for it (such as the name used to identify the IEEP).  Your code may look a bit like this:  @Override\npublic void saveNBTData(NBTTagCompound compound) {\n  NBTTagCompound propertyData = new NBTTagCompound();\n\n  // Write data to propertyData\n\n  compound.setTag(PROP_NAME, propertyData);\n}\n\n@Override\npublic void loadNBTData(NBTTagCompound compound) {\n  if(compound.hasKey(PROP_NAME, Constants.NBT.TAG_COMPOUND)) {\n    NBTTagCompound propertyData = compound.getCompoundTag(PROP_NAME);\n\n    // Read data from propertyData\n  }\n}",
            "title": "Saving and Loading Data from NBT"
        },
        {
            "location": "/datastorage/extendedentityproperties/#synchronizing-data-with-clients",
            "text": "By default, the entity data is not sent to clients. In order to change this, the mods have to manage their own synchronization code using packets.  There are three different situation in which you may want to send synchronization packets, all of them optional:   When the entity spawns in the world, you may want to share the initialization-assigned values with the clients.  When the stored data changes, you may want to notify some or all of the watching clients.  When a new client starts viewing the entity, you may want to notify it of the existing data.   Refer to the  Networking  page for more information on implementing the network packets.  For example:  private void dataChanged() {\n  if(!world.isRemote) {\n    EntityTracker tracker = ((WorldServer)world).getEntityTracker();\n    ExampleEntityPropertySync message = new ExampleEntityPropertySync(this);\n\n    for (EntityPlayer entityPlayer : tracker.getTrackingPlayers(entity)) {\n      ExampleMod.channel.sendTo(message, (EntityPlayerMP)entityPlayer);\n    }\n  }\n}\n\nprivate void entitySpawned() {\n  dataChanged();\n}\n\nprivate void playerStartedTracking(EntityPlayer entityPlayer) {\n  ExampleMod.channel.sendTo(new ExampleEntityPropertySync(this), (EntityPlayerMP)entityPlayer);\n}  And the corresponding event handlers:  @SubscribeEvent\npublic void entityJoinWorld(EntityJoinWorldEvent e) {\n  ExampleEntityProperty data = ExampleEntityProperty.get(e.entity);\n  if (data != null)\n    data.entitySpawned();\n}\n\n@SubscribeEvent\npublic void playerStartedTracking(PlayerEvent.StartTracking e) {\n  ExampleEntityProperty data = ExampleEntityProperty.get(e.target);\n  if (data != null)\n    data.playerStartedTracking(e.entityPlayer);\n}",
            "title": "Synchronizing Data with Clients"
        },
        {
            "location": "/datastorage/extendedentityproperties/#persisting-across-player-deaths",
            "text": "By default, the entity data does not persist on death. In order to change this, the data has to be manually copied when the player entity is cloned during the respawn process.  This can be done by handling the  PlayerEvent.Clone  event. In this event, the  wasDead  field can be used to distinguish between respawning after death, and returning from the End. This is important because the data will already exist, so care has to be taken to not duplicate values when returning from the End dimension.  @SubscribeEvent\npublic void onClonePlayer(PlayerEvent.Clone e) {\n  if(e.wasDeath) {\n    NBTTagCompound compound = new NBTTagCompound();\n    ExampleEntityProperty.get(e.original).saveNBTData(compound);\n    ExampleEntityProperty.get(e.entityPlayer).loadNBTData(compound);\n  }\n}",
            "title": "Persisting across Player Deaths"
        },
        {
            "location": "/utilities/oredictionary/",
            "text": "OreDictionary\n\n\nThe OreDictionary exists primarily for inter-mod compatibility. \n\n\nItems that are registered to the OreDictionary become interchangeable with other items that have the same OreDictionary name. This allows recipes to use either item to produce the same result.\n\n\nDespite its name, the OreDictionary is used for much more than ores. Any item that is similar to another item (for example, dyes) can be registered to and used with the OreDictionary.\n\n\nOreDictionary Name Convention\n\n\n\n\nNote\n\n\nBecause OreDictionary names are meant to be shared between items from different mods, they should be fairly general. Use a name that other mods are likely to use.\n\n\n\n\nForge does not require names to be in any particular format, but the following has become a popular standard for OreDictionary names:\n\n\nThe entire OreDictionary name typically uses camelCase (compound words that begin with a lowercase letter, where each successive word begins with a capital letter) and avoids spaces or underscores.\n\n\nThe first word in the OreDictionary name indicates the type of item. For unique items (such as \nrecord\n, \ndirt\n, \negg\n, and \nvine\n), one word is specific enough.\n\n\nThe last part of the name indicates the material of the item. This differentiates between \ningotIron\n and \ningotGold\n, for example.\n\n\nWhen two words are not specific enough, a third word can be added. For instance, granite is registered as \nblockGranite\n while polished granite is registered as \nblockGranitePolished\n.\n\n\nSee \nCommon OreDictionary Names\n for a list of commonly used prefixes and suffixes.\n\n\nWILDCARD_VALUE\n\n\nThis value is used to indicate that the metadata of an \nItemStack\n is not important. See \nbelow\n for an example of its use.\n\n\nUsing OreDictionary in Crafting Recipes\n\n\nRecipes that use the OreDictionary are created and registered in much the same way as regular crafting recipes. The main difference is the use of an OreDictionary name instead of a specific \nItem\n or \nItemStack\n.\n\n\nTo make a recipe that can use OreDictionary entries, create a \nShapelessOreRecipe\n or \nShapedOreRecipe\n instance and register it by calling \nGameRegistry.addRecipe(IRecipe recipe)\n.\n\n\n\n\nNote\n\n\nYou can verify that an OreDictionary name will return a valid \nItemStack\n by calling \nOreDictionary.doesOreNameExist(String name)\n.\n\n\n\n\nAnother use of the OreDictionary in crafting is the \nWILDCARD_VALUE\n. Use by passing \nOreDictionary.WILDCARD_VALUE\n in the constructor of an \nItemStack\n.\n\n\n\n\nNote\n\n\nOreDictionary.WILDCARD_VALUE\n should only be used for the recipe input. Using \nWILDCARD_VALUE\n in the recipe output will only hardcode the damage of the output \nItemStack\n.\n\n\n\n\nRegistering Items to the OreDictionary\n\n\nAdd entries to the OreDictionary during the \nFMLPreInitializationEvent\n phase, after initializing the blocks and items that you will register.\n\n\nSimply call \nOreDictionary.registerOre(ItemStack stack, String name)\n with an \nItemStack\n containing your item or block and its metadata value to register it to the OreDictionary.\n\n\nYou can also call one of the overloads of \nOreDictionary.registerOre\n that take a \nBlock\n or \nItem\n to avoid creating the \nItemStack\n yourself.\n\n\nSee \nOreDictionary Name Convention\n for tips on formatting the OreDictionary name of the \nItemStack\n.\n\n\nCommon OreDictionary Names\n\n\nAll OreDictionary names for Minecraft items and blocks can be found in \nnet.minecraftforge.oredict.OreDictionary\n. A full list will not be included here.\n\n\nCommon prefixes already used in the OreDictionary include \nore\n, \ningot\n, \nnugget\n, \ndust\n, \ngem\n, \ndye\n, \nblock\n, \nstone\n, \ncrop\n, \nslab\n, \nstair\n, and \npane\n.\n\n\nCommon prefixes for modded items include \ngear\n, \nrod\n, \nstick\n, \nplate\n, \ndustTiny\n, and \ncover\n. \n\n\nCommon suffixes in the OreDictionary include \nWood\n, \nGlass\n, \nIron\n, \nGold\n, \nLeaves\n, and \nBrick\n. \n\n\nCommon suffixes for modded items include the names of metals (\nCopper\n, \nAluminum\n, \nLead\n, \nSteel\n, etc.) and other modded materials.",
            "title": "OreDictionary"
        },
        {
            "location": "/utilities/oredictionary/#oredictionary",
            "text": "The OreDictionary exists primarily for inter-mod compatibility.   Items that are registered to the OreDictionary become interchangeable with other items that have the same OreDictionary name. This allows recipes to use either item to produce the same result.  Despite its name, the OreDictionary is used for much more than ores. Any item that is similar to another item (for example, dyes) can be registered to and used with the OreDictionary.",
            "title": "OreDictionary"
        },
        {
            "location": "/utilities/oredictionary/#oredictionary-name-convention",
            "text": "Note  Because OreDictionary names are meant to be shared between items from different mods, they should be fairly general. Use a name that other mods are likely to use.   Forge does not require names to be in any particular format, but the following has become a popular standard for OreDictionary names:  The entire OreDictionary name typically uses camelCase (compound words that begin with a lowercase letter, where each successive word begins with a capital letter) and avoids spaces or underscores.  The first word in the OreDictionary name indicates the type of item. For unique items (such as  record ,  dirt ,  egg , and  vine ), one word is specific enough.  The last part of the name indicates the material of the item. This differentiates between  ingotIron  and  ingotGold , for example.  When two words are not specific enough, a third word can be added. For instance, granite is registered as  blockGranite  while polished granite is registered as  blockGranitePolished .  See  Common OreDictionary Names  for a list of commonly used prefixes and suffixes.",
            "title": "OreDictionary Name Convention"
        },
        {
            "location": "/utilities/oredictionary/#wildcard_value",
            "text": "This value is used to indicate that the metadata of an  ItemStack  is not important. See  below  for an example of its use.",
            "title": "WILDCARD_VALUE"
        },
        {
            "location": "/utilities/oredictionary/#using-oredictionary-in-crafting-recipes",
            "text": "Recipes that use the OreDictionary are created and registered in much the same way as regular crafting recipes. The main difference is the use of an OreDictionary name instead of a specific  Item  or  ItemStack .  To make a recipe that can use OreDictionary entries, create a  ShapelessOreRecipe  or  ShapedOreRecipe  instance and register it by calling  GameRegistry.addRecipe(IRecipe recipe) .   Note  You can verify that an OreDictionary name will return a valid  ItemStack  by calling  OreDictionary.doesOreNameExist(String name) .   Another use of the OreDictionary in crafting is the  WILDCARD_VALUE . Use by passing  OreDictionary.WILDCARD_VALUE  in the constructor of an  ItemStack .   Note  OreDictionary.WILDCARD_VALUE  should only be used for the recipe input. Using  WILDCARD_VALUE  in the recipe output will only hardcode the damage of the output  ItemStack .",
            "title": "Using OreDictionary in Crafting Recipes"
        },
        {
            "location": "/utilities/oredictionary/#registering-items-to-the-oredictionary",
            "text": "Add entries to the OreDictionary during the  FMLPreInitializationEvent  phase, after initializing the blocks and items that you will register.  Simply call  OreDictionary.registerOre(ItemStack stack, String name)  with an  ItemStack  containing your item or block and its metadata value to register it to the OreDictionary.  You can also call one of the overloads of  OreDictionary.registerOre  that take a  Block  or  Item  to avoid creating the  ItemStack  yourself.  See  OreDictionary Name Convention  for tips on formatting the OreDictionary name of the  ItemStack .",
            "title": "Registering Items to the OreDictionary"
        },
        {
            "location": "/utilities/oredictionary/#common-oredictionary-names",
            "text": "All OreDictionary names for Minecraft items and blocks can be found in  net.minecraftforge.oredict.OreDictionary . A full list will not be included here.  Common prefixes already used in the OreDictionary include  ore ,  ingot ,  nugget ,  dust ,  gem ,  dye ,  block ,  stone ,  crop ,  slab ,  stair , and  pane .  Common prefixes for modded items include  gear ,  rod ,  stick ,  plate ,  dustTiny , and  cover .   Common suffixes in the OreDictionary include  Wood ,  Glass ,  Iron ,  Gold ,  Leaves , and  Brick .   Common suffixes for modded items include the names of metals ( Copper ,  Aluminum ,  Lead ,  Steel , etc.) and other modded materials.",
            "title": "Common OreDictionary Names"
        },
        {
            "location": "/effects/sounds/",
            "text": "Sounds\n\n\nTerminology\n\n\n\n\n\n\n\n\nTerm\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSound Events\n\n\nSomething that triggers a sound effect. Examples include \n\"minecraft:block.anvil.hit\"\n or \n\"botania:spreaderFire\"\n.\n\n\n\n\n\n\nSound Category\n\n\nThe category of the sound, for example \n\"player\"\n, \n\"block\"\n or simply \n\"master\"\n. The sliders in the sound settings GUI represent these categories.\n\n\n\n\n\n\nSound File\n\n\nThe literal file on disk that is played, usually an .ogg file.\n\n\n\n\n\n\n\n\nsounds.json\n\n\nThis json should be located in the \nassets\n directory of a mod: \nsrc/main/resources/assets/<modid>/sounds.json\n. This file declares sound events and identifies which sound files they use.\n\n\nA full specification is available on the vanilla \nwiki\n, but this example highlights the important parts:\n\n\n{\n  \"open_chest\": {\n    \"category\": \"block\",\n    \"subtitle\": \"mymod.subtitle.openChest\",\n    \"sounds\": [ \"mymod:open_chest_sound_file\" ]\n  },\n  \"epic_music\": {\n    \"category\": \"record\",\n    \"sounds\": [\n      {\n        \"name\": \"mymod:music/epic_music\",\n        \"stream\": true\n      }\n    ]\n  }\n}\n\n\n\n\n\n\nImportant\n\n\nLike the rest of the resource system, everything_should_be_in_snake_case.\n\n\n\n\nUnderneath the top-level object, each key corresponds to a sound event. Note that they are written in the sounds.json without the modid. Each event specifies its category, and a localization key to be shown when subtitles are enabled. Finally, the actual sound files to be played are specified. Note that the value is an array; if multiple sound files are specified then the game will randomly choose one to play whenever the sound event is triggered.\n\n\nThe two examples represent two different ways to specify a sound file. The \nwiki\n has precise details, but generally, long sound files such as BGM or music discs should use the second form, because the \u201cstream\u201d argument tells Minecraft to not load the entire sound file into memory but instead to stream it from disk. The second form can also specify the volume, pitch, and random weight of that sound file.\n\n\nIn all cases, the path to a sound file for domain \ndomain\n and path \npath\n is \nassets/<domain>/sounds/<path>.ogg\n. Therefore \nmymod:open_chest_sound_file\n points to \nassets/mymod/sounds/open_chest_sound_file.ogg\n, and \nmymod:music/epic_music\n points to \nassets/mymod/sounds/music/epic_music.ogg\n.\n\n\nCreating Sound Events\n\n\nIn order to actually be able to play sounds, a \nSoundEvent\n corresponding to an entry in \nsounds.json\n must be created. This \nSoundEvent\n must then be \nregistered\n. Normally, the location used to create a sound event should be set as it\u2019s registry name.\n\n\nCreating a \nSoundEvent\n:\n\n\nResourceLocation location = new ResourceLocation(\"mymod\", \"open_chest\");\nSoundEvent event = new SoundEvent(location);\n\n\n\n\nThe \nSoundEvent\n acts as a reference to the sound, and is passed around to actually play sounds. Therefore, the \nSoundEvent\n should be stored somewhere. If a mod has an API, it should expose its \nSoundEvent\ns in the API.\n\n\nPlaying Sounds\n\n\nVanilla has lots of methods for playing sounds, and it\u2019s unclear which to use at times.\n\n\n\n\nNote\n\n\nThis information was gathered by looking at these various methods, analyzing their usage and categorizing them accordingly. It is up-to-date as of Forge 1907, please let someone know if it is out of date!\n\n\n\n\nNote that each takes a \nSoundEvent\n, the ones registered above. Additionally, the terms \n\u201cServer Behavior\u201d\n and \n\u201cClient Behavior\u201d\n refer to the respective \nlogical\n side\n.\n\n\nWorld\n\n\n\n\n\n\n \nplaySound(EntityPlayer, BlockPos, SoundEvent, SoundCategory, volume, pitch)\n\n\n\n\nSimply forwards to \noverload (2)\n, adding 0.5 to each coordinate of the \nBlockPos\n given.\n\n\n\n\n\n\n\n\n \nplaySound(EntityPlayer, double x, double y, double z, SoundEvent, SoundCategory, volume, pitch)\n\n\n\n\nClient Behavior\n: If the passed in player is \nthe\n client player, plays the sound event to the client player.\n\n\nServer Behavior\n: Plays the sound event to everyone nearby \nexcept\n the passed in player. Player can be \nnull\n.\n\n\nUsage\n: The correspondence between the behaviors implies that these two methods are to be called from some player-initiated code that will be run on both logical sides at the same time - the logical client handles playing it to the user and the logical server handles everyone else hearing it without re-playing it to the original user.\n   They can also be used to play any sound in general at any position server-side by calling it on the logical server and passing in a \nnull\n player, thus letting everyone hear it.\n\n\n\n\n\n\n\n\n \nplaySound(double x, double y, double z, SoundEvent, SoundCategory, volume, pitch, distanceDelay)\n\n\n\n\nClient Behavior\n: Just plays the sound event in the client world. If \ndistanceDelay\n is \ntrue\n, then delays the sound based on how far it is from the player.\n\n\nServer Behavior\n: Does nothing.\n\n\nUsage\n: This method only works client-side, and thus is useful for sounds sent in custom packets, or other client-only effect-type sounds. Used for thunder.\n\n\n\n\n\n\n\n\nWorldClient\n\n\n\n\n \nplaySound(BlockPos, SoundEvent, SoundCategory, volume, pitch, distanceDelay)\n\n\nSimply forwards to \nWorld\n\u2018s \noverload (3)\n, adding 0.5 to each coordinate of the \nBlockPos\n given.\n\n\n\n\n\n\n\n\nEntity\n\n\n\n\n \nplaySound(SoundEvent, volume, pitch)\n\n\nForwards to \nWorld\n\u2018s \noverload (2)\n, passing in \nnull\n as the player.\n\n\nClient Behavior\n: Does nothing.\n\n\nServer Behavior\n: Plays the sound event to everyone at this entity\u2019s position.\n\n\nUsage\n: Emitting any sound from any non-player entity server-side.\n\n\n\n\n\n\n\n\nEntityPlayer\n\n\n\n\n \nplaySound(SoundEvent, volume, pitch)\n (overriding the one in \nEntity\n)\n\n\nForwards to \nWorld\n\u2018s \noverload (2)\n, passing in \nthis\n as the player.\n\n\nClient Behavior\n: Does nothing, see override in \nEntityPlayerSP\n.\n\n\nServer Behavior\n: Plays the sound to everyone nearby \nexcept\n this player.\n\n\nUsage\n: See \nEntityPlayerSP\n.\n\n\n\n\n\n\n\n\nEntityPlayerSP\n\n\n\n\n \nplaySound(SoundEvent, volume, pitch)\n (overriding the one in \nEntityPlayer\n)\n\n\nForwards to \nWorld\n\u2018s \noverload (2)\n, passing in \nthis\n as the player.\n\n\nClient Behavior\n: Just plays the Sound Event.\n\n\nServer Behavior\n: Method is client-only.\n\n\nUsage\n: Just like the ones in \nWorld\n, these two overrides in the player classes seem to be for code that runs together on both sides. The client handles playing the sound to the user, while the server handles everyone else hearing it without re-playing to the original user.",
            "title": "Sounds"
        },
        {
            "location": "/effects/sounds/#sounds",
            "text": "",
            "title": "Sounds"
        },
        {
            "location": "/effects/sounds/#terminology",
            "text": "Term  Description      Sound Events  Something that triggers a sound effect. Examples include  \"minecraft:block.anvil.hit\"  or  \"botania:spreaderFire\" .    Sound Category  The category of the sound, for example  \"player\" ,  \"block\"  or simply  \"master\" . The sliders in the sound settings GUI represent these categories.    Sound File  The literal file on disk that is played, usually an .ogg file.",
            "title": "Terminology"
        },
        {
            "location": "/effects/sounds/#soundsjson",
            "text": "This json should be located in the  assets  directory of a mod:  src/main/resources/assets/<modid>/sounds.json . This file declares sound events and identifies which sound files they use.  A full specification is available on the vanilla  wiki , but this example highlights the important parts:  {\n  \"open_chest\": {\n    \"category\": \"block\",\n    \"subtitle\": \"mymod.subtitle.openChest\",\n    \"sounds\": [ \"mymod:open_chest_sound_file\" ]\n  },\n  \"epic_music\": {\n    \"category\": \"record\",\n    \"sounds\": [\n      {\n        \"name\": \"mymod:music/epic_music\",\n        \"stream\": true\n      }\n    ]\n  }\n}   Important  Like the rest of the resource system, everything_should_be_in_snake_case.   Underneath the top-level object, each key corresponds to a sound event. Note that they are written in the sounds.json without the modid. Each event specifies its category, and a localization key to be shown when subtitles are enabled. Finally, the actual sound files to be played are specified. Note that the value is an array; if multiple sound files are specified then the game will randomly choose one to play whenever the sound event is triggered.  The two examples represent two different ways to specify a sound file. The  wiki  has precise details, but generally, long sound files such as BGM or music discs should use the second form, because the \u201cstream\u201d argument tells Minecraft to not load the entire sound file into memory but instead to stream it from disk. The second form can also specify the volume, pitch, and random weight of that sound file.  In all cases, the path to a sound file for domain  domain  and path  path  is  assets/<domain>/sounds/<path>.ogg . Therefore  mymod:open_chest_sound_file  points to  assets/mymod/sounds/open_chest_sound_file.ogg , and  mymod:music/epic_music  points to  assets/mymod/sounds/music/epic_music.ogg .",
            "title": "sounds.json"
        },
        {
            "location": "/effects/sounds/#creating-sound-events",
            "text": "In order to actually be able to play sounds, a  SoundEvent  corresponding to an entry in  sounds.json  must be created. This  SoundEvent  must then be  registered . Normally, the location used to create a sound event should be set as it\u2019s registry name.  Creating a  SoundEvent :  ResourceLocation location = new ResourceLocation(\"mymod\", \"open_chest\");\nSoundEvent event = new SoundEvent(location);  The  SoundEvent  acts as a reference to the sound, and is passed around to actually play sounds. Therefore, the  SoundEvent  should be stored somewhere. If a mod has an API, it should expose its  SoundEvent s in the API.",
            "title": "Creating Sound Events"
        },
        {
            "location": "/effects/sounds/#playing-sounds",
            "text": "Vanilla has lots of methods for playing sounds, and it\u2019s unclear which to use at times.   Note  This information was gathered by looking at these various methods, analyzing their usage and categorizing them accordingly. It is up-to-date as of Forge 1907, please let someone know if it is out of date!   Note that each takes a  SoundEvent , the ones registered above. Additionally, the terms  \u201cServer Behavior\u201d  and  \u201cClient Behavior\u201d  refer to the respective  logical  side .",
            "title": "Playing Sounds"
        },
        {
            "location": "/effects/sounds/#world",
            "text": "playSound(EntityPlayer, BlockPos, SoundEvent, SoundCategory, volume, pitch)   Simply forwards to  overload (2) , adding 0.5 to each coordinate of the  BlockPos  given.       playSound(EntityPlayer, double x, double y, double z, SoundEvent, SoundCategory, volume, pitch)   Client Behavior : If the passed in player is  the  client player, plays the sound event to the client player.  Server Behavior : Plays the sound event to everyone nearby  except  the passed in player. Player can be  null .  Usage : The correspondence between the behaviors implies that these two methods are to be called from some player-initiated code that will be run on both logical sides at the same time - the logical client handles playing it to the user and the logical server handles everyone else hearing it without re-playing it to the original user.\n   They can also be used to play any sound in general at any position server-side by calling it on the logical server and passing in a  null  player, thus letting everyone hear it.       playSound(double x, double y, double z, SoundEvent, SoundCategory, volume, pitch, distanceDelay)   Client Behavior : Just plays the sound event in the client world. If  distanceDelay  is  true , then delays the sound based on how far it is from the player.  Server Behavior : Does nothing.  Usage : This method only works client-side, and thus is useful for sounds sent in custom packets, or other client-only effect-type sounds. Used for thunder.",
            "title": "World"
        },
        {
            "location": "/effects/sounds/#worldclient",
            "text": "playSound(BlockPos, SoundEvent, SoundCategory, volume, pitch, distanceDelay)  Simply forwards to  World \u2018s  overload (3) , adding 0.5 to each coordinate of the  BlockPos  given.",
            "title": "WorldClient"
        },
        {
            "location": "/effects/sounds/#entity",
            "text": "playSound(SoundEvent, volume, pitch)  Forwards to  World \u2018s  overload (2) , passing in  null  as the player.  Client Behavior : Does nothing.  Server Behavior : Plays the sound event to everyone at this entity\u2019s position.  Usage : Emitting any sound from any non-player entity server-side.",
            "title": "Entity"
        },
        {
            "location": "/effects/sounds/#entityplayer",
            "text": "playSound(SoundEvent, volume, pitch)  (overriding the one in  Entity )  Forwards to  World \u2018s  overload (2) , passing in  this  as the player.  Client Behavior : Does nothing, see override in  EntityPlayerSP .  Server Behavior : Plays the sound to everyone nearby  except  this player.  Usage : See  EntityPlayerSP .",
            "title": "EntityPlayer"
        },
        {
            "location": "/effects/sounds/#entityplayersp",
            "text": "playSound(SoundEvent, volume, pitch)  (overriding the one in  EntityPlayer )  Forwards to  World \u2018s  overload (2) , passing in  this  as the player.  Client Behavior : Just plays the Sound Event.  Server Behavior : Method is client-only.  Usage : Just like the ones in  World , these two overrides in the player classes seem to be for code that runs together on both sides. The client handles playing the sound to the user, while the server handles everyone else hearing it without re-playing to the original user.",
            "title": "EntityPlayerSP"
        },
        {
            "location": "/conventions/versioning/",
            "text": "Versioning\n\n\nIn general projects, \nSemantic Versioning\n is often used (which has the format \nMAJOR.MINOR.PATCH\n). However, in the case of modding it may be more beneficial to use the format \nMCVERSION-MAJORMOD.MAJORAPI.MINOR.PATCH\n, to be able to differentiate between world-breaking and API-breaking changes of a mod.\n\n\nExamples\n\n\nHere is a (most likely incomplete) list of things that increment the various variables.\n\n\n\n\nMCVERSION\n\n\nAlways matches the Minecraft version the mod is for.\n\n\n\n\n\n\nMAJORMOD\n\n\nRemoving items, blocks, tile entities, etc.\n\n\nChanging or removing previously existing mechanics.\n\n\nUpdating to a new Minecraft version.\n\n\n\n\n\n\nMAJORAPI\n\n\nChanging the order or variables of enums.\n\n\nChanging return types of methods.\n\n\nRemoving public methods altogether.\n\n\n\n\n\n\nMINOR\n\n\nAdding items, blocks, tile entities, etc.\n\n\nAdding new mechanics.\n\n\nDeprecating public methods. (This is not a \nMAJORAPI\n increment since it doesn\u2019t break an API.)\n\n\n\n\n\n\nPATCH\n\n\nBugfixes.\n\n\n\n\n\n\n\n\nWhen incrementing any variable, all lesser variables should reset to \n0\n. For instance, if \nMINOR\n would increment, \nPATCH\n would become \n0\n. If \nMAJORMOD\n would increment, all other variables would become \n0\n.\n\n\nWork In Progress\n\n\nIf you are in the initial development stage of your mod (before any official releases), the \nMAJORMOD\n and \nMAJORAPI\n should always be \n0\n. Only \nMINOR\n should be updated every time you build your mod. Once you build an official release (most of the time with a stable API), you should increment \nMAJORMOD\n to version \n1.0.0.0\n. For any further development stages, refer to the \nPrereleases\n and \nRelease candidates\n section of this document.\n\n\nMultiple Minecraft Versions\n\n\nIf the mod upgrades to a new version of Minecraft, and the old version will only receive bug fixes, the \nPATCH\n variable should be updated based on the version before the upgrade. If the mod is still in active development in both the old and the new version of Minecraft, it is advised to append the version to \nboth\n build numbers. For example, if the mod is upgraded to version \n3.0.0.0\n due to a Minecraft version change, the old mod should also be updated to \n3.0.0.0\n. The old version will become, for example, version \n1.7.10-3.0.0.0\n, while the new version will become \n1.8-3.0.0.0\n. If there are no changes at all when building for a newer Minecraft version, all variables except for the Minecraft version should stay the same.\n\n\nFinal Release\n\n\nWhen dropping support for a Minecraft version, the last build for that version should get the \n-final\n suffix. This denotes that the mod will no longer be supported for the denoted \nMCVERSION\n and that players should upgrade to a newer version of the mod to continue receiving updates and bug fixes.\n\n\nPre-releases\n\n\nIt is also possible to prerelease work-in-progress features, which means new features are released that are not quite done yet. These can be seen as a sort of \u201cbeta\u201d. These versions should be appended with \n-betaX\n, where X is the number of the prerelease. (This guide does not use \n-pre\n since, at the time of writing, it is not a valid alias for \n-beta\n according to Forge.) Note that already released versions and versions before the initial release can not go into prerelease; variables (mostly \nMINOR\n, but \nMAJORAPI\n and \nMAJORMOD\n can also prerelease) should be updated accordingly before adding the \n-beta\n suffix. Versions before the initial release are simply work-in-progress builds.\n\n\nRelease Candidates\n\n\nRelease candidates act as prereleases before an actual version change. These versions should be appended with \n-rcX\n, where \nX\n is the number of the release candidate which should, in theory, only be increased for bugfixes. Already released versions can not receive release candidates; variables (mostly \nMINOR\n, but \nMAJORAPI\n and \nMAJORMOD\n can also prerelease)  should be updated accordingly before adding the \n-rc\n suffix. When releasing a release candidate as stable build, it can either be exactly the same as the last release candidate or have a few more bug fixes.",
            "title": "Versioning"
        },
        {
            "location": "/conventions/versioning/#versioning",
            "text": "In general projects,  Semantic Versioning  is often used (which has the format  MAJOR.MINOR.PATCH ). However, in the case of modding it may be more beneficial to use the format  MCVERSION-MAJORMOD.MAJORAPI.MINOR.PATCH , to be able to differentiate between world-breaking and API-breaking changes of a mod.",
            "title": "Versioning"
        },
        {
            "location": "/conventions/versioning/#examples",
            "text": "Here is a (most likely incomplete) list of things that increment the various variables.   MCVERSION  Always matches the Minecraft version the mod is for.    MAJORMOD  Removing items, blocks, tile entities, etc.  Changing or removing previously existing mechanics.  Updating to a new Minecraft version.    MAJORAPI  Changing the order or variables of enums.  Changing return types of methods.  Removing public methods altogether.    MINOR  Adding items, blocks, tile entities, etc.  Adding new mechanics.  Deprecating public methods. (This is not a  MAJORAPI  increment since it doesn\u2019t break an API.)    PATCH  Bugfixes.     When incrementing any variable, all lesser variables should reset to  0 . For instance, if  MINOR  would increment,  PATCH  would become  0 . If  MAJORMOD  would increment, all other variables would become  0 .",
            "title": "Examples"
        },
        {
            "location": "/conventions/versioning/#work-in-progress",
            "text": "If you are in the initial development stage of your mod (before any official releases), the  MAJORMOD  and  MAJORAPI  should always be  0 . Only  MINOR  should be updated every time you build your mod. Once you build an official release (most of the time with a stable API), you should increment  MAJORMOD  to version  1.0.0.0 . For any further development stages, refer to the  Prereleases  and  Release candidates  section of this document.",
            "title": "Work In Progress"
        },
        {
            "location": "/conventions/versioning/#multiple-minecraft-versions",
            "text": "If the mod upgrades to a new version of Minecraft, and the old version will only receive bug fixes, the  PATCH  variable should be updated based on the version before the upgrade. If the mod is still in active development in both the old and the new version of Minecraft, it is advised to append the version to  both  build numbers. For example, if the mod is upgraded to version  3.0.0.0  due to a Minecraft version change, the old mod should also be updated to  3.0.0.0 . The old version will become, for example, version  1.7.10-3.0.0.0 , while the new version will become  1.8-3.0.0.0 . If there are no changes at all when building for a newer Minecraft version, all variables except for the Minecraft version should stay the same.",
            "title": "Multiple Minecraft Versions"
        },
        {
            "location": "/conventions/versioning/#final-release",
            "text": "When dropping support for a Minecraft version, the last build for that version should get the  -final  suffix. This denotes that the mod will no longer be supported for the denoted  MCVERSION  and that players should upgrade to a newer version of the mod to continue receiving updates and bug fixes.",
            "title": "Final Release"
        },
        {
            "location": "/conventions/versioning/#pre-releases",
            "text": "It is also possible to prerelease work-in-progress features, which means new features are released that are not quite done yet. These can be seen as a sort of \u201cbeta\u201d. These versions should be appended with  -betaX , where X is the number of the prerelease. (This guide does not use  -pre  since, at the time of writing, it is not a valid alias for  -beta  according to Forge.) Note that already released versions and versions before the initial release can not go into prerelease; variables (mostly  MINOR , but  MAJORAPI  and  MAJORMOD  can also prerelease) should be updated accordingly before adding the  -beta  suffix. Versions before the initial release are simply work-in-progress builds.",
            "title": "Pre-releases"
        },
        {
            "location": "/conventions/versioning/#release-candidates",
            "text": "Release candidates act as prereleases before an actual version change. These versions should be appended with  -rcX , where  X  is the number of the release candidate which should, in theory, only be increased for bugfixes. Already released versions can not receive release candidates; variables (mostly  MINOR , but  MAJORAPI  and  MAJORMOD  can also prerelease)  should be updated accordingly before adding the  -rc  suffix. When releasing a release candidate as stable build, it can either be exactly the same as the last release candidate or have a few more bug fixes.",
            "title": "Release Candidates"
        },
        {
            "location": "/conventions/locations/",
            "text": "Locations\n\n\nMinecraft expects certain parts of your project to be in certain locations, such as textures and JSONs.\n\n\nAll locations and items covered in this page are relative to your \n./src/main/resources/\n folder.\n\n\nmcmod.info\n\n\nThe \nmcmod.info\n file is in the root directory.\n\n\nBlockstates\n\n\nBlockstate definition files are in the JSON format and are in the \n./assets/<modid>/blockstates/\n folder.\n\n\nLocalizations\n\n\nLocalizations are plain-text files with the file extension .lang and the name being their \nlanguage code\n such as \nen_US\n.\n\n\nThey are located in the \n./assets/<modid>/lang/\n folder.\n\n\nModels\n\n\nModel files are in JSON format and are located in \n./assets/<modid>/models/block/\n or \n./assets/<modid>/models/item/\n depending on whether they are for a block or an item, respectively.\n\n\nTextures\n\n\nTextures are in the PNG format and are located in \n./assets/<modid>/textures/blocks/\n or \n./assets/<modid>/textures/items/\n depending on whether they are for a block or an item, respectively.",
            "title": "Locations"
        },
        {
            "location": "/conventions/locations/#locations",
            "text": "Minecraft expects certain parts of your project to be in certain locations, such as textures and JSONs.  All locations and items covered in this page are relative to your  ./src/main/resources/  folder.",
            "title": "Locations"
        },
        {
            "location": "/conventions/locations/#mcmodinfo",
            "text": "The  mcmod.info  file is in the root directory.",
            "title": "mcmod.info"
        },
        {
            "location": "/conventions/locations/#blockstates",
            "text": "Blockstate definition files are in the JSON format and are in the  ./assets/<modid>/blockstates/  folder.",
            "title": "Blockstates"
        },
        {
            "location": "/conventions/locations/#localizations",
            "text": "Localizations are plain-text files with the file extension .lang and the name being their  language code  such as  en_US .  They are located in the  ./assets/<modid>/lang/  folder.",
            "title": "Localizations"
        },
        {
            "location": "/conventions/locations/#models",
            "text": "Model files are in JSON format and are located in  ./assets/<modid>/models/block/  or  ./assets/<modid>/models/item/  depending on whether they are for a block or an item, respectively.",
            "title": "Models"
        },
        {
            "location": "/conventions/locations/#textures",
            "text": "Textures are in the PNG format and are located in  ./assets/<modid>/textures/blocks/  or  ./assets/<modid>/textures/items/  depending on whether they are for a block or an item, respectively.",
            "title": "Textures"
        },
        {
            "location": "/conventions/loadstages/",
            "text": "Loading Stages\n\n\nForge loads your mod in 3 main stages: Pre-Initialization, Initialization, and Post-Initialization, commonly referred to as preInit, init, and postInit.\nThere are some other events that are important too, depending on what your mod does.\nEach of these stages occurs at a different point in the loading stage and thus what can be safely done in each stage varies.\n\n\n\n\nNote\n\n\nLoading stage events can only be used in your \n@Mod\n class, in methods marked with the \n@EventHandler\n annotation.\n\n\n\n\nPre-Initialization\n\n\nPre Init is the place to let the game know about all the blocks, items, etc that your mod provides.\nThis stage\u2019s event is the \nFMLPreInitializationEvent\n.\nCommon actions to preform in preInit are:\n\n\n\n\nRegistering blocks and items to the GameRegistry\n\n\nRegistering tile entities\n\n\nRegistering entities\n\n\nAssigning ore dictionary names\n\n\n\n\nInitialization\n\n\nInit is where to accomplish any game related tasks that rely upon the items and blocks set up in preInit.\nThis stage\u2019s event is the \nFMLInitializationEvent\n.\nCommon actions to preform in init are:\n\n\n\n\nRegistering world generators\n\n\nRegistering recipes\n\n\nRegistering event handlers\n\n\nSending IMC messages\n\n\n\n\nPost-Initialization\n\n\nPost Init is where your mod usually does things which rely upon or are relied upon by other mods.\nThis stage\u2019s event is the \nFMLPostInitializationEvent\n.\nCommon actions to preform in postInit are:\n\n\n\n\nMod compatibility, or anything which depends on other mods\u2019 init phases being finished.\n\n\n\n\nOther Important Events\n\n\n\n\nIMCEvent: Process received IMC Messages\n\n\nFMLServerStartingEvent: Register Commands",
            "title": "Loading Stages"
        },
        {
            "location": "/conventions/loadstages/#loading-stages",
            "text": "Forge loads your mod in 3 main stages: Pre-Initialization, Initialization, and Post-Initialization, commonly referred to as preInit, init, and postInit.\nThere are some other events that are important too, depending on what your mod does.\nEach of these stages occurs at a different point in the loading stage and thus what can be safely done in each stage varies.   Note  Loading stage events can only be used in your  @Mod  class, in methods marked with the  @EventHandler  annotation.",
            "title": "Loading Stages"
        },
        {
            "location": "/conventions/loadstages/#pre-initialization",
            "text": "Pre Init is the place to let the game know about all the blocks, items, etc that your mod provides.\nThis stage\u2019s event is the  FMLPreInitializationEvent .\nCommon actions to preform in preInit are:   Registering blocks and items to the GameRegistry  Registering tile entities  Registering entities  Assigning ore dictionary names",
            "title": "Pre-Initialization"
        },
        {
            "location": "/conventions/loadstages/#initialization",
            "text": "Init is where to accomplish any game related tasks that rely upon the items and blocks set up in preInit.\nThis stage\u2019s event is the  FMLInitializationEvent .\nCommon actions to preform in init are:   Registering world generators  Registering recipes  Registering event handlers  Sending IMC messages",
            "title": "Initialization"
        },
        {
            "location": "/conventions/loadstages/#post-initialization",
            "text": "Post Init is where your mod usually does things which rely upon or are relied upon by other mods.\nThis stage\u2019s event is the  FMLPostInitializationEvent .\nCommon actions to preform in postInit are:   Mod compatibility, or anything which depends on other mods\u2019 init phases being finished.",
            "title": "Post-Initialization"
        },
        {
            "location": "/conventions/loadstages/#other-important-events",
            "text": "IMCEvent: Process received IMC Messages  FMLServerStartingEvent: Register Commands",
            "title": "Other Important Events"
        }
    ]
}